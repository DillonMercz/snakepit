{"version":3,"file":"static/js/68.489f2833.chunk.js","mappings":"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","sources":["gameLogic.js"],"sourcesContent":["// Weapon configuration data\r\nconst WEAPON_CONFIGS = {\r\n    // Default sidearm - always available\r\n    sidearm: {\r\n        name: 'Snake Fang',\r\n        tier: 0,\r\n        damage: 1,\r\n        maxAmmo: Infinity,\r\n        fireRate: 300, // Reduced from 800 for more frequent shooting\r\n        projectileSpeed: 12,\r\n        accuracy: 90,\r\n        rarity: 'default',\r\n        color: '#888888',\r\n        secondaryColor: '#AAAAAA',\r\n        glowColor: '#CCCCCC',\r\n        accentColor: '#EEEEEE',\r\n        ammoTypes: [],\r\n        description: 'Basic sidearm with unlimited ammo'\r\n    },\r\n\r\n    // Tier 1: Light Weapons\r\n    laser_pistol: {\r\n        name: 'Laser Pistol',\r\n        tier: 1,\r\n        damage: 2,\r\n        maxAmmo: 24,\r\n        fireRate: 400,\r\n        projectileSpeed: 18,\r\n        accuracy: 95,\r\n        rarity: 'common',\r\n        color: '#FF4444',\r\n        secondaryColor: '#FF7777',\r\n        glowColor: '#FFAAAA',\r\n        accentColor: '#FFCCCC',\r\n        ammoTypes: ['light_energy'],\r\n        description: 'Fast-firing energy sidearm'\r\n    },\r\n\r\n    plasma_smg: {\r\n        name: 'Plasma SMG',\r\n        tier: 1,\r\n        damage: 1.5,\r\n        maxAmmo: 30,\r\n        fireRate: 200,\r\n        projectileSpeed: 15,\r\n        accuracy: 85,\r\n        rarity: 'common',\r\n        color: '#44FF44',\r\n        secondaryColor: '#77FF77',\r\n        glowColor: '#AAFFAA',\r\n        accentColor: '#CCFFCC',\r\n        ammoTypes: ['plasma_cells'],\r\n        description: 'Rapid-fire plasma weapon',\r\n        firingMode: 'full_auto' // Full auto firing mode\r\n    },\r\n\r\n    // Tier 2: Medium Weapons\r\n    laser_rifle: {\r\n        name: 'Laser Rifle',\r\n        tier: 2,\r\n        damage: 3,\r\n        maxAmmo: 30,\r\n        fireRate: 600,\r\n        projectileSpeed: 20,\r\n        accuracy: 98,\r\n        rarity: 'uncommon',\r\n        color: '#FF2222',\r\n        secondaryColor: '#FF6666',\r\n        glowColor: '#FF9999',\r\n        accentColor: '#FFCCCC',\r\n        ammoTypes: ['light_energy', 'heavy_energy'],\r\n        description: 'Accurate long-range laser',\r\n        firingMode: 'tri_burst_sequential', // Sequential tri-burst mode\r\n        burstCount: 3,\r\n        burstDelay: 100, // 100ms between shots in burst\r\n        burstCooldown: 800 // 800ms cooldown after burst\r\n    },\r\n\r\n    plasma_cannon: {\r\n        name: 'Plasma Cannon',\r\n        tier: 2,\r\n        damage: 5,\r\n        maxAmmo: 15,\r\n        fireRate: 1000,\r\n        projectileSpeed: 16,\r\n        accuracy: 90,\r\n        rarity: 'uncommon',\r\n        color: '#22FF22',\r\n        secondaryColor: '#66FF66',\r\n        glowColor: '#99FF99',\r\n        accentColor: '#CCFFCC',\r\n        ammoTypes: ['plasma_cells', 'heavy_plasma'],\r\n        description: 'Heavy plasma artillery',\r\n        firingMode: 'tri_burst_spread', // Spread tri-burst mode\r\n        burstCount: 3,\r\n        spreadAngle: 0.3 // 0.3 radians spread between shots\r\n    },\r\n\r\n    // Tier 3: Heavy Weapons\r\n    rocket_launcher: {\r\n        name: 'Rocket Launcher',\r\n        tier: 3,\r\n        damage: 8,\r\n        maxAmmo: 8,\r\n        fireRate: 2000,\r\n        projectileSpeed: 14,\r\n        accuracy: 85,\r\n        rarity: 'rare',\r\n        color: '#FF6622',\r\n        secondaryColor: '#FF9966',\r\n        glowColor: '#FFCC99',\r\n        accentColor: '#FFDDCC',\r\n        ammoTypes: ['rockets'],\r\n        description: 'Explosive rocket weapon'\r\n    },\r\n\r\n    rail_gun: {\r\n        name: 'Rail Gun',\r\n        tier: 3,\r\n        damage: 12,\r\n        maxAmmo: 5,\r\n        fireRate: 3000,\r\n        projectileSpeed: 25,\r\n        accuracy: 100,\r\n        rarity: 'rare',\r\n        color: '#4444FF',\r\n        secondaryColor: '#7777FF',\r\n        glowColor: '#AAAAFF',\r\n        accentColor: '#CCCCFF',\r\n        ammoTypes: ['rail_slugs'],\r\n        description: 'Piercing electromagnetic weapon'\r\n    },\r\n\r\n    // Tier 4: Ultimate Weapons\r\n    minigun: {\r\n        name: 'Minigun',\r\n        tier: 4,\r\n        damage: 2,\r\n        maxAmmo: 500,\r\n        fireRate: 60, // Very fast fire rate (60ms between shots)\r\n        projectileSpeed: 12,\r\n        accuracy: 75, // Lower accuracy due to rapid fire\r\n        rarity: 'legendary',\r\n        color: '#FF0000',\r\n        secondaryColor: '#FF4444',\r\n        glowColor: '#FF8888',\r\n        accentColor: '#FFCCCC',\r\n        ammoTypes: ['heavy_energy', 'heavy_plasma'],\r\n        description: 'Rapid-fire heavy weapon with massive ammo capacity',\r\n        spinUp: true, // Special property for minigun spin-up mechanic\r\n        spinUpTime: 1000, // 1 second to reach full fire rate\r\n        maxSpinLevel: 10, // Maximum spin level for fire rate bonus\r\n        firingMode: 'full_auto', // Full auto firing mode\r\n        tracerRounds: true // Uses tracer rounds\r\n    }\r\n};\r\n\r\n// Ammo configuration\r\nconst AMMO_CONFIGS = {\r\n    light_energy: {\r\n        name: 'Energy Cells',\r\n        color: '#FFFF44',\r\n        minAmount: 15,\r\n        maxAmount: 30,\r\n        rarity: 'common'\r\n    },\r\n    heavy_energy: {\r\n        name: 'Heavy Energy',\r\n        color: '#FFAA44',\r\n        minAmount: 8,\r\n        maxAmount: 15,\r\n        rarity: 'uncommon'\r\n    },\r\n    plasma_cells: {\r\n        name: 'Plasma Cells',\r\n        color: '#44FFAA',\r\n        minAmount: 10,\r\n        maxAmount: 20,\r\n        rarity: 'common'\r\n    },\r\n    heavy_plasma: {\r\n        name: 'Heavy Plasma',\r\n        color: '#44FF44',\r\n        minAmount: 5,\r\n        maxAmount: 10,\r\n        rarity: 'uncommon'\r\n    },\r\n    rockets: {\r\n        name: 'Rockets',\r\n        color: '#FF8844',\r\n        minAmount: 2,\r\n        maxAmount: 6,\r\n        rarity: 'rare'\r\n    },\r\n    rail_slugs: {\r\n        name: 'Rail Slugs',\r\n        color: '#8844FF',\r\n        minAmount: 1,\r\n        maxAmount: 3,\r\n        rarity: 'rare'\r\n    }\r\n};\r\n\r\n// Powerup configuration\r\nconst POWERUP_CONFIGS = {\r\n    helmet: {\r\n        name: 'Combat Helmet',\r\n        type: 'defensive',\r\n        duration: Infinity, // Permanent until destroyed\r\n        damageReduction: 0.0, // No damage reduction, just head protection\r\n        headProtection: 1.0, // 100% protection until destroyed\r\n        helmetHealth: 500, // Takes 500 damage before breaking\r\n        rarity: 'common',\r\n        color: '#888888',\r\n        secondaryColor: '#AAAAAA',\r\n        glowColor: '#CCCCCC',\r\n        description: 'Absorbs 500 damage to head before breaking'\r\n    },\r\n    forcefield: {\r\n        name: 'Energy Forcefield',\r\n        type: 'defensive',\r\n        duration: 20000, // 20 seconds\r\n        damageReduction: 0.75, // 75% damage reduction\r\n        headProtection: 0.95, // 95% chance to survive headshot\r\n        rarity: 'uncommon',\r\n        color: '#44AAFF',\r\n        secondaryColor: '#66CCFF',\r\n        glowColor: '#88DDFF',\r\n        description: 'Advanced energy shield with superior protection'\r\n    },\r\n    armor_plating: {\r\n        name: 'Armor Plating',\r\n        type: 'defensive',\r\n        duration: 45000, // 45 seconds\r\n        damageReduction: 0.3, // 30% damage reduction\r\n        headProtection: 0.4, // 40% chance to survive headshot\r\n        rarity: 'common',\r\n        color: '#666666',\r\n        secondaryColor: '#999999',\r\n        glowColor: '#BBBBBB',\r\n        description: 'Heavy armor plating for extended protection'\r\n    },\r\n    battering_ram: {\r\n        name: 'Battering Ram',\r\n        type: 'offensive',\r\n        duration: 25000, // 25 seconds\r\n        boostDamage: 75, // Damage dealt when boosting into segments\r\n        speedBoost: 1.5, // 50% speed increase\r\n        rarity: 'rare',\r\n        color: '#FF6600',\r\n        secondaryColor: '#FF9933',\r\n        glowColor: '#FFCC66',\r\n        description: 'Ram through enemy segments while boosting, increased speed'\r\n    },\r\n    shield_generator: {\r\n        name: 'Shield Generator',\r\n        type: 'defensive',\r\n        duration: 15000, // 15 seconds\r\n        damageReduction: 0.9, // 90% damage reduction\r\n        headProtection: 0.99, // 99% chance to survive headshot\r\n        rarity: 'rare',\r\n        color: '#00FFAA',\r\n        secondaryColor: '#33FFBB',\r\n        glowColor: '#66FFCC',\r\n        description: 'Experimental shield technology'\r\n    }\r\n};\r\n\r\nclass Weapon {\r\n    constructor(x, y, type = null) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.size = 25;\r\n        this.collected = false;\r\n        this.type = type || this.randomWeaponType();\r\n        this.animationOffset = Math.random() * Math.PI * 2;\r\n\r\n        // Get weapon configuration\r\n        this.config = WEAPON_CONFIGS[this.type] || WEAPON_CONFIGS.sidearm;\r\n        this.setWeaponProperties();\r\n        this.currentAmmo = this.maxAmmo;\r\n\r\n        // Individual weapon timing\r\n        this.lastShotTime = 0;\r\n\r\n        // Burst firing state\r\n        this.burstState = {\r\n            inBurst: false,\r\n            shotsInBurst: 0,\r\n            lastBurstShotTime: 0,\r\n            burstCooldownStart: 0\r\n        };\r\n\r\n        // Visual effects\r\n        this.pulsePhase = Math.random() * Math.PI * 2;\r\n        this.rotationSpeed = 0.5 + Math.random() * 1.0;\r\n    }\r\n\r\n    randomWeaponType() {\r\n        const types = ['laser_pistol', 'plasma_smg', 'laser_rifle', 'plasma_cannon', 'rocket_launcher', 'rail_gun', 'minigun'];\r\n        // Weight the selection based on rarity\r\n        const weights = [30, 30, 20, 15, 5, 1, 0.5]; // Common weapons more likely, minigun extremely rare\r\n\r\n        let totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n\r\n        for (let i = 0; i < types.length; i++) {\r\n            random -= weights[i];\r\n            if (random <= 0) {\r\n                return types[i];\r\n            }\r\n        }\r\n\r\n        return types[0]; // Fallback\r\n    }\r\n\r\n    setWeaponProperties() {\r\n        // Copy properties from config\r\n        this.name = this.config.name;\r\n        this.tier = this.config.tier;\r\n        this.damage = this.config.damage;\r\n        this.maxAmmo = this.config.maxAmmo;\r\n        this.fireRate = this.config.fireRate;\r\n        this.projectileSpeed = this.config.projectileSpeed;\r\n        this.accuracy = this.config.accuracy;\r\n        this.rarity = this.config.rarity;\r\n        this.color = this.config.color;\r\n        this.secondaryColor = this.config.secondaryColor;\r\n        this.glowColor = this.config.glowColor;\r\n        this.accentColor = this.config.accentColor;\r\n        this.ammoTypes = this.config.ammoTypes;\r\n        this.description = this.config.description;\r\n    }\r\n\r\n    canShoot() {\r\n        if (this.currentAmmo <= 0) return false;\r\n\r\n        const now = Date.now();\r\n        const firingMode = this.config.firingMode || 'semi_auto';\r\n\r\n        switch (firingMode) {\r\n            case 'tri_burst_sequential':\r\n                // Check if we're in a burst\r\n                if (this.burstState.inBurst) {\r\n                    // Check if we can fire the next shot in the burst\r\n                    return now - this.burstState.lastBurstShotTime >= (this.config.burstDelay || 100);\r\n                } else {\r\n                    // Check if burst cooldown is over\r\n                    return now - this.burstState.burstCooldownStart >= (this.config.burstCooldown || 800);\r\n                }\r\n\r\n            case 'tri_burst_spread':\r\n                // Spread burst fires all shots at once, so just check cooldown\r\n                return now - this.lastShotTime >= this.fireRate;\r\n\r\n            case 'full_auto':\r\n            case 'semi_auto':\r\n            default:\r\n                return now - this.lastShotTime >= this.fireRate;\r\n        }\r\n    }\r\n\r\n    shoot() {\r\n        if (this.canShoot()) {\r\n            this.currentAmmo--;\r\n            this.lastShotTime = Date.now();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    reload(ammoAmount) {\r\n        const ammoNeeded = this.maxAmmo - this.currentAmmo;\r\n        const ammoToAdd = Math.min(ammoAmount, ammoNeeded);\r\n        this.currentAmmo += ammoToAdd;\r\n        return ammoAmount - ammoToAdd; // Return remaining ammo\r\n    }\r\n\r\n    getAmmoPercentage() {\r\n        return this.currentAmmo / this.maxAmmo;\r\n    }\r\n\r\n    draw(ctx, cameraX, cameraY) {\r\n        if (this.collected) return;\r\n\r\n        const screenX = this.x - cameraX;\r\n        const screenY = this.y - cameraY;\r\n\r\n        // Don't draw if off screen\r\n        if (screenX < -100 || screenX > ctx.canvas.width + 100 ||\r\n            screenY < -100 || screenY > ctx.canvas.height + 100) {\r\n            return;\r\n        }\r\n\r\n        const time = Date.now() * 0.001;\r\n\r\n        // Enhanced weapon bubble design\r\n        this.drawWeaponContainer(ctx, screenX, screenY, time);\r\n        this.drawAmmoIndicator(ctx, screenX, screenY, time);\r\n        this.drawWeaponDetails(ctx, screenX, screenY, time);\r\n        this.drawWeaponEffects(ctx, screenX, screenY, time);\r\n    }\r\n\r\n    drawWeaponContainer(ctx, x, y, time) {\r\n        const baseSize = this.size;\r\n        const pulse = Math.sin(time * 2 + this.pulsePhase) * 0.1 + 1;\r\n        const containerSize = baseSize * pulse;\r\n\r\n        // Outer energy field\r\n        const outerGradient = ctx.createRadialGradient(x, y, 0, x, y, containerSize * 2.2);\r\n        outerGradient.addColorStop(0, this.color + '30');\r\n        outerGradient.addColorStop(0.4, this.color + '20');\r\n        outerGradient.addColorStop(0.8, this.color + '10');\r\n        outerGradient.addColorStop(1, 'transparent');\r\n\r\n        ctx.fillStyle = outerGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, containerSize * 2.2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Main container (hexagonal design)\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n        ctx.rotate(time * this.rotationSpeed + this.animationOffset);\r\n\r\n        // Hexagonal container\r\n        const hexRadius = containerSize * 0.9;\r\n        ctx.beginPath();\r\n        for (let i = 0; i < 6; i++) {\r\n            const angle = (i * Math.PI) / 3;\r\n            const hx = Math.cos(angle) * hexRadius;\r\n            const hy = Math.sin(angle) * hexRadius;\r\n            if (i === 0) ctx.moveTo(hx, hy);\r\n            else ctx.lineTo(hx, hy);\r\n        }\r\n        ctx.closePath();\r\n\r\n        // Container gradient\r\n        const containerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, hexRadius);\r\n        containerGradient.addColorStop(0, this.accentColor + 'CC');\r\n        containerGradient.addColorStop(0.3, this.secondaryColor + 'AA');\r\n        containerGradient.addColorStop(0.7, this.color + '88');\r\n        containerGradient.addColorStop(1, this.color + 'DD');\r\n\r\n        ctx.fillStyle = containerGradient;\r\n        ctx.fill();\r\n\r\n        // Container border\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 3;\r\n        ctx.stroke();\r\n\r\n        // Inner hexagon detail\r\n        const innerHexRadius = hexRadius * 0.7;\r\n        ctx.beginPath();\r\n        for (let i = 0; i < 6; i++) {\r\n            const angle = (i * Math.PI) / 3;\r\n            const hx = Math.cos(angle) * innerHexRadius;\r\n            const hy = Math.sin(angle) * innerHexRadius;\r\n            if (i === 0) ctx.moveTo(hx, hy);\r\n            else ctx.lineTo(hx, hy);\r\n        }\r\n        ctx.closePath();\r\n\r\n        ctx.strokeStyle = this.secondaryColor + '80';\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawAmmoIndicator(ctx, x, y, time) {\r\n        const ammoPercentage = this.getAmmoPercentage();\r\n        const indicatorRadius = this.size * 1.1;\r\n\r\n        // Ammo ring background\r\n        ctx.strokeStyle = '#333333';\r\n        ctx.lineWidth = 6;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, indicatorRadius, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n\r\n        // Ammo ring fill\r\n        const ammoAngle = ammoPercentage * Math.PI * 2;\r\n        let ammoColor;\r\n        if (ammoPercentage > 0.6) ammoColor = '#00FF00';\r\n        else if (ammoPercentage > 0.3) ammoColor = '#FFFF00';\r\n        else ammoColor = '#FF0000';\r\n\r\n        if (ammoPercentage > 0) {\r\n            ctx.strokeStyle = ammoColor;\r\n            ctx.lineWidth = 4;\r\n            ctx.lineCap = 'round';\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, indicatorRadius, -Math.PI / 2, -Math.PI / 2 + ammoAngle);\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Ammo count text\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.font = 'bold 10px monospace';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText(`${this.currentAmmo}`, x, y + this.size * 1.4);\r\n    }\r\n\r\n    drawWeaponDetails(ctx, x, y, time) {\r\n        const iconSize = this.size * 0.5;\r\n\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n\r\n        // Weapon-specific detailed icon\r\n        switch (this.type) {\r\n            case 'sidearm':\r\n                this.drawSidearmWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n            case 'laser_pistol':\r\n            case 'laser_rifle':\r\n                this.drawLaserWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n            case 'plasma_smg':\r\n            case 'plasma_cannon':\r\n                this.drawPlasmaWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n            case 'rocket_launcher':\r\n                this.drawMissileWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n            case 'rail_gun':\r\n                this.drawRailGunWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n            case 'minigun':\r\n                this.drawMinigunWeaponIcon(ctx, iconSize, time);\r\n                break;\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n        // Weapon name\r\n        ctx.fillStyle = this.color;\r\n        ctx.font = 'bold 8px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText(this.name, x, y - this.size * 1.6);\r\n    }\r\n\r\n    drawWeaponEffects(ctx, x, y, time) {\r\n        // Energy particles\r\n        const particleCount = 12;\r\n        for (let i = 0; i < particleCount; i++) {\r\n            const angle = (time * 1.5 + i * (Math.PI * 2 / particleCount)) % (Math.PI * 2);\r\n            const distance = this.size * (1.8 + Math.sin(time * 3 + i) * 0.4);\r\n            const particleX = x + Math.cos(angle) * distance;\r\n            const particleY = y + Math.sin(angle) * distance;\r\n\r\n            const particleSize = 1.5 + Math.sin(time * 4 + i) * 0.8;\r\n            const alpha = 0.4 + Math.sin(time * 5 + i) * 0.3;\r\n\r\n            // Particle glow\r\n            const particleGradient = ctx.createRadialGradient(\r\n                particleX, particleY, 0,\r\n                particleX, particleY, particleSize * 3\r\n            );\r\n            particleGradient.addColorStop(0, this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));\r\n            particleGradient.addColorStop(0.5, this.secondaryColor + Math.floor(alpha * 128).toString(16).padStart(2, '0'));\r\n            particleGradient.addColorStop(1, 'transparent');\r\n\r\n            ctx.fillStyle = particleGradient;\r\n            ctx.beginPath();\r\n            ctx.arc(particleX, particleY, particleSize * 3, 0, Math.PI * 2);\r\n            ctx.fill();\r\n\r\n            // Particle core\r\n            ctx.fillStyle = this.accentColor;\r\n            ctx.beginPath();\r\n            ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        // Central energy pulse\r\n        const pulseSize = this.size * 0.3 * (1 + Math.sin(time * 6 + this.pulsePhase) * 0.5);\r\n        const pulseGradient = ctx.createRadialGradient(x, y, 0, x, y, pulseSize);\r\n        pulseGradient.addColorStop(0, '#FFFFFF');\r\n        pulseGradient.addColorStop(0.5, this.color);\r\n        pulseGradient.addColorStop(1, 'transparent');\r\n\r\n        ctx.fillStyle = pulseGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, pulseSize, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    drawLaserWeaponIcon(ctx, size, time) {\r\n        // Laser rifle design\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Rifle body\r\n        ctx.fillRect(-size * 0.8, -size * 0.2, size * 1.6, size * 0.4);\r\n        ctx.strokeRect(-size * 0.8, -size * 0.2, size * 1.6, size * 0.4);\r\n\r\n        // Barrel\r\n        ctx.fillRect(size * 0.8, -size * 0.1, size * 0.4, size * 0.2);\r\n        ctx.strokeRect(size * 0.8, -size * 0.1, size * 0.4, size * 0.2);\r\n\r\n        // Energy core (pulsing)\r\n        const corePulse = 0.7 + Math.sin(time * 8) * 0.3;\r\n        ctx.fillStyle = this.color + Math.floor(corePulse * 255).toString(16).padStart(2, '0');\r\n        ctx.fillRect(-size * 0.3, -size * 0.15, size * 0.6, size * 0.3);\r\n\r\n        // Laser sight lines\r\n        ctx.strokeStyle = '#FF0000';\r\n        ctx.lineWidth = 1;\r\n        for (let i = 0; i < 3; i++) {\r\n            const offset = (i - 1) * size * 0.1;\r\n            ctx.beginPath();\r\n            ctx.moveTo(size * 1.2, offset);\r\n            ctx.lineTo(size * 1.5, offset);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawPlasmaWeaponIcon(ctx, size, time) {\r\n        // Plasma cannon design\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Cannon body (wider)\r\n        ctx.fillRect(-size * 0.9, -size * 0.3, size * 1.8, size * 0.6);\r\n        ctx.strokeRect(-size * 0.9, -size * 0.3, size * 1.8, size * 0.6);\r\n\r\n        // Plasma chamber (circular)\r\n        ctx.beginPath();\r\n        ctx.arc(-size * 0.2, 0, size * 0.25, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Plasma energy (animated)\r\n        const plasmaPulse = 0.5 + Math.sin(time * 6) * 0.5;\r\n        const plasmaGradient = ctx.createRadialGradient(-size * 0.2, 0, 0, -size * 0.2, 0, size * 0.2);\r\n        plasmaGradient.addColorStop(0, '#FFFFFF');\r\n        plasmaGradient.addColorStop(0.5, this.color);\r\n        plasmaGradient.addColorStop(1, this.secondaryColor);\r\n\r\n        ctx.fillStyle = plasmaGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(-size * 0.2, 0, size * 0.15 * plasmaPulse, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Barrel with energy coils\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 3;\r\n        for (let i = 0; i < 4; i++) {\r\n            const x = size * 0.3 + i * size * 0.2;\r\n            ctx.beginPath();\r\n            ctx.arc(x, 0, size * 0.15, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawMissileWeaponIcon(ctx, size, time) {\r\n        // Rocket launcher design\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Launcher tube\r\n        ctx.fillRect(-size * 1.0, -size * 0.25, size * 2.0, size * 0.5);\r\n        ctx.strokeRect(-size * 1.0, -size * 0.25, size * 2.0, size * 0.5);\r\n\r\n        // Missile inside (if ammo > 0)\r\n        if (this.currentAmmo > 0) {\r\n            ctx.fillStyle = this.secondaryColor;\r\n            ctx.fillRect(size * 0.2, -size * 0.15, size * 0.6, size * 0.3);\r\n\r\n            // Missile tip\r\n            ctx.beginPath();\r\n            ctx.moveTo(size * 0.8, 0);\r\n            ctx.lineTo(size * 1.0, -size * 0.1);\r\n            ctx.lineTo(size * 1.0, size * 0.1);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n\r\n        // Launcher details\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(-size * 0.8, -size * 0.35, size * 0.3, size * 0.7);\r\n\r\n        // Exhaust ports\r\n        for (let i = 0; i < 3; i++) {\r\n            const y = (i - 1) * size * 0.15;\r\n            ctx.beginPath();\r\n            ctx.arc(-size * 1.1, y, size * 0.05, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawSidearmWeaponIcon(ctx, size, time) {\r\n        // Simple sidearm design\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Gun body\r\n        ctx.fillRect(-size * 0.6, -size * 0.15, size * 1.2, size * 0.3);\r\n        ctx.strokeRect(-size * 0.6, -size * 0.15, size * 1.2, size * 0.3);\r\n\r\n        // Barrel\r\n        ctx.fillRect(size * 0.6, -size * 0.08, size * 0.3, size * 0.16);\r\n        ctx.strokeRect(size * 0.6, -size * 0.08, size * 0.3, size * 0.16);\r\n\r\n        // Grip\r\n        ctx.fillRect(-size * 0.4, size * 0.15, size * 0.2, size * 0.4);\r\n        ctx.strokeRect(-size * 0.4, size * 0.15, size * 0.2, size * 0.4);\r\n    }\r\n\r\n    drawRailGunWeaponIcon(ctx, size, time) {\r\n        // Rail gun design\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Main body (longer and thicker)\r\n        ctx.fillRect(-size * 1.1, -size * 0.2, size * 2.2, size * 0.4);\r\n        ctx.strokeRect(-size * 1.1, -size * 0.2, size * 2.2, size * 0.4);\r\n\r\n        // Rail guides (top and bottom)\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(-size * 1.0, -size * 0.25, size * 2.0, size * 0.1);\r\n        ctx.strokeRect(-size * 1.0, size * 0.15, size * 2.0, size * 0.1);\r\n\r\n        // Energy chamber (pulsing)\r\n        const energyPulse = 0.6 + Math.sin(time * 10) * 0.4;\r\n        ctx.fillStyle = this.color + Math.floor(energyPulse * 255).toString(16).padStart(2, '0');\r\n        ctx.fillRect(-size * 0.2, -size * 0.1, size * 0.4, size * 0.2);\r\n\r\n        // Electromagnetic coils\r\n        ctx.strokeStyle = '#4444FF';\r\n        ctx.lineWidth = 2;\r\n        for (let i = 0; i < 3; i++) {\r\n            const x = -size * 0.6 + i * size * 0.4;\r\n            ctx.beginPath();\r\n            ctx.arc(x, 0, size * 0.12, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawMinigunWeaponIcon(ctx, size, time) {\r\n        // Minigun design with rotating barrels\r\n        const rotationSpeed = time * 5; // Fast rotation for minigun effect\r\n\r\n        ctx.save();\r\n        ctx.rotate(rotationSpeed);\r\n\r\n        // Multiple rotating barrels\r\n        const barrelCount = 6;\r\n        const barrelRadius = size * 0.3;\r\n\r\n        for (let i = 0; i < barrelCount; i++) {\r\n            const angle = (i / barrelCount) * Math.PI * 2;\r\n            const barrelX = Math.cos(angle) * barrelRadius;\r\n            const barrelY = Math.sin(angle) * barrelRadius;\r\n\r\n            // Individual barrel\r\n            ctx.fillStyle = this.color;\r\n            ctx.strokeStyle = this.secondaryColor;\r\n            ctx.lineWidth = 1;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(barrelX, barrelY, size * 0.08, 0, Math.PI * 2);\r\n            ctx.fill();\r\n            ctx.stroke();\r\n\r\n            // Barrel opening\r\n            ctx.fillStyle = '#000000';\r\n            ctx.beginPath();\r\n            ctx.arc(barrelX, barrelY, size * 0.04, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n        // Central hub\r\n        ctx.fillStyle = this.secondaryColor;\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Weapon body/handle\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(-size * 0.1, size * 0.2, size * 0.2, size * 0.4);\r\n        ctx.strokeRect(-size * 0.1, size * 0.2, size * 0.2, size * 0.4);\r\n\r\n        // Ammo feed\r\n        ctx.fillStyle = this.accentColor;\r\n        ctx.fillRect(-size * 0.15, size * 0.1, size * 0.3, size * 0.15);\r\n        ctx.strokeRect(-size * 0.15, size * 0.1, size * 0.3, size * 0.15);\r\n\r\n        // Muzzle flash effect (if spinning fast)\r\n        if (Math.sin(time * 10) > 0.5) {\r\n            const flashGradient = ctx.createRadialGradient(0, -size * 0.5, 0, 0, -size * 0.5, size * 0.3);\r\n            flashGradient.addColorStop(0, '#FFFF00');\r\n            flashGradient.addColorStop(0.5, '#FF8800');\r\n            flashGradient.addColorStop(1, 'transparent');\r\n\r\n            ctx.fillStyle = flashGradient;\r\n            ctx.beginPath();\r\n            ctx.arc(0, -size * 0.5, size * 0.3, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n\r\n// New Ammo class for separate ammo pickups\r\nclass Ammo {\r\n    constructor(x, y, type = null, amount = null) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.size = 15;\r\n        this.collected = false;\r\n        this.type = type || this.randomAmmoType();\r\n        this.animationOffset = Math.random() * Math.PI * 2;\r\n\r\n        // Set ammo properties\r\n        this.setAmmoProperties(amount);\r\n\r\n        // Visual effects\r\n        this.bobPhase = Math.random() * Math.PI * 2;\r\n        this.sparklePhase = Math.random() * Math.PI * 2;\r\n    }\r\n\r\n    randomAmmoType() {\r\n        const types = ['light_energy', 'plasma_cells', 'heavy_energy', 'heavy_plasma', 'rockets', 'rail_slugs'];\r\n        const weights = [30, 25, 20, 15, 8, 2]; // Common ammo more likely\r\n\r\n        let totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n\r\n        for (let i = 0; i < types.length; i++) {\r\n            random -= weights[i];\r\n            if (random <= 0) {\r\n                return types[i];\r\n            }\r\n        }\r\n\r\n        return types[0]; // Fallback\r\n    }\r\n\r\n    setAmmoProperties(customAmount = null) {\r\n        const config = AMMO_CONFIGS[this.type];\r\n        if (config) {\r\n            this.color = config.color;\r\n            this.secondaryColor = this.lightenColor(config.color);\r\n            this.name = config.name;\r\n            this.rarity = config.rarity;\r\n            this.amount = customAmount || (config.minAmount + Math.floor(Math.random() * (config.maxAmount - config.minAmount + 1)));\r\n        } else {\r\n            // Fallback for unknown types\r\n            this.color = '#FFFFFF';\r\n            this.secondaryColor = '#CCCCCC';\r\n            this.amount = customAmount || 10;\r\n            this.name = 'Unknown Ammo';\r\n            this.rarity = 'common';\r\n        }\r\n    }\r\n\r\n    lightenColor(color) {\r\n        // Simple color lightening function\r\n        const hex = color.replace('#', '');\r\n        const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + 60);\r\n        const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + 60);\r\n        const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + 60);\r\n        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n    }\r\n\r\n    draw(ctx, cameraX, cameraY) {\r\n        if (this.collected) return;\r\n\r\n        const screenX = this.x - cameraX;\r\n        const screenY = this.y - cameraY;\r\n\r\n        // Don't draw if off screen\r\n        if (screenX < -50 || screenX > ctx.canvas.width + 50 ||\r\n            screenY < -50 || screenY > ctx.canvas.height + 50) {\r\n            return;\r\n        }\r\n\r\n        const time = Date.now() * 0.001;\r\n        const bobOffset = Math.sin(time * 3 + this.bobPhase) * 3;\r\n        const finalY = screenY + bobOffset;\r\n\r\n        this.drawAmmoContainer(ctx, screenX, finalY, time);\r\n        this.drawAmmoIcon(ctx, screenX, finalY, time);\r\n        this.drawAmmoEffects(ctx, screenX, finalY, time);\r\n    }\r\n\r\n    drawAmmoContainer(ctx, x, y, time) {\r\n        const pulse = 0.9 + Math.sin(time * 4 + this.animationOffset) * 0.1;\r\n        const containerSize = this.size * pulse;\r\n\r\n        // Outer glow\r\n        const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, containerSize * 2);\r\n        glowGradient.addColorStop(0, this.color + '60');\r\n        glowGradient.addColorStop(0.5, this.color + '30');\r\n        glowGradient.addColorStop(1, 'transparent');\r\n\r\n        ctx.fillStyle = glowGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(x, y, containerSize * 2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Main container (diamond shape)\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n        ctx.rotate(time * 1.5 + this.animationOffset);\r\n\r\n        const diamondSize = containerSize * 0.8;\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, -diamondSize);\r\n        ctx.lineTo(diamondSize, 0);\r\n        ctx.lineTo(0, diamondSize);\r\n        ctx.lineTo(-diamondSize, 0);\r\n        ctx.closePath();\r\n\r\n        // Container gradient\r\n        const containerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, diamondSize);\r\n        containerGradient.addColorStop(0, '#FFFFFF');\r\n        containerGradient.addColorStop(0.3, this.secondaryColor);\r\n        containerGradient.addColorStop(1, this.color);\r\n\r\n        ctx.fillStyle = containerGradient;\r\n        ctx.fill();\r\n\r\n        // Container border\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawAmmoIcon(ctx, x, y, time) {\r\n        const iconSize = this.size * 0.4;\r\n\r\n        ctx.save();\r\n        ctx.translate(x, y);\r\n\r\n        // Ammo type icon\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 1;\r\n\r\n        switch (this.type) {\r\n            case 'laser':\r\n                // Battery/cell icon\r\n                ctx.fillRect(-iconSize * 0.3, -iconSize * 0.6, iconSize * 0.6, iconSize * 1.2);\r\n                ctx.strokeRect(-iconSize * 0.3, -iconSize * 0.6, iconSize * 0.6, iconSize * 1.2);\r\n                // Positive terminal\r\n                ctx.fillRect(-iconSize * 0.1, -iconSize * 0.8, iconSize * 0.2, iconSize * 0.2);\r\n                break;\r\n\r\n            case 'plasma':\r\n                // Energy core icon\r\n                ctx.beginPath();\r\n                ctx.arc(0, 0, iconSize * 0.5, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                // Energy lines\r\n                for (let i = 0; i < 4; i++) {\r\n                    const angle = i * Math.PI / 2;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(Math.cos(angle) * iconSize * 0.3, Math.sin(angle) * iconSize * 0.3);\r\n                    ctx.lineTo(Math.cos(angle) * iconSize * 0.7, Math.sin(angle) * iconSize * 0.7);\r\n                    ctx.stroke();\r\n                }\r\n                break;\r\n\r\n            case 'missile':\r\n                // Rocket icon\r\n                ctx.fillRect(-iconSize * 0.1, -iconSize * 0.6, iconSize * 0.2, iconSize * 1.2);\r\n                ctx.strokeRect(-iconSize * 0.1, -iconSize * 0.6, iconSize * 0.2, iconSize * 1.2);\r\n                // Warhead\r\n                ctx.beginPath();\r\n                ctx.moveTo(0, -iconSize * 0.6);\r\n                ctx.lineTo(-iconSize * 0.1, -iconSize * 0.8);\r\n                ctx.lineTo(iconSize * 0.1, -iconSize * 0.8);\r\n                ctx.closePath();\r\n                ctx.fill();\r\n                ctx.stroke();\r\n                // Fins\r\n                ctx.strokeRect(-iconSize * 0.3, iconSize * 0.4, iconSize * 0.2, iconSize * 0.2);\r\n                ctx.strokeRect(iconSize * 0.1, iconSize * 0.4, iconSize * 0.2, iconSize * 0.2);\r\n                break;\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n        // Ammo count\r\n        ctx.fillStyle = this.color;\r\n        ctx.font = 'bold 8px monospace';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText(`+${this.amount}`, x, y + this.size * 1.2);\r\n    }\r\n\r\n    drawAmmoEffects(ctx, x, y, time) {\r\n        // Sparkle effects\r\n        const sparkleCount = 6;\r\n        for (let i = 0; i < sparkleCount; i++) {\r\n            const angle = (time * 2 + this.sparklePhase + i * (Math.PI * 2 / sparkleCount)) % (Math.PI * 2);\r\n            const distance = this.size * (1.2 + Math.sin(time * 4 + i) * 0.3);\r\n            const sparkleX = x + Math.cos(angle) * distance;\r\n            const sparkleY = y + Math.sin(angle) * distance;\r\n\r\n            const sparkleSize = 1 + Math.sin(time * 6 + i) * 0.5;\r\n            const alpha = 0.6 + Math.sin(time * 8 + i) * 0.4;\r\n\r\n            ctx.fillStyle = this.secondaryColor + Math.floor(alpha * 255).toString(16).padStart(2, '0');\r\n            ctx.beginPath();\r\n            ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n}\r\n\r\n// Powerup class for defensive and offensive powerups\r\nclass Powerup {\r\n    constructor(x, y, type = null) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.size = 20;\r\n        this.collected = false;\r\n        this.type = type || this.randomPowerupType();\r\n        this.animationOffset = Math.random() * Math.PI * 2;\r\n\r\n        // Get powerup configuration\r\n        this.config = POWERUP_CONFIGS[this.type] || POWERUP_CONFIGS.helmet;\r\n        this.setPowerupProperties();\r\n\r\n        // Visual effects\r\n        this.bobPhase = Math.random() * Math.PI * 2;\r\n        this.pulsePhase = Math.random() * Math.PI * 2;\r\n        this.rotationSpeed = 1.0 + Math.random() * 0.5;\r\n    }\r\n\r\n    randomPowerupType() {\r\n        const types = Object.keys(POWERUP_CONFIGS);\r\n        const weights = types.map(type => {\r\n            const rarity = POWERUP_CONFIGS[type].rarity;\r\n            switch (rarity) {\r\n                case 'common': return 50;\r\n                case 'uncommon': return 25;\r\n                case 'rare': return 10;\r\n                default: return 30;\r\n            }\r\n        });\r\n\r\n        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n\r\n        for (let i = 0; i < types.length; i++) {\r\n            random -= weights[i];\r\n            if (random <= 0) {\r\n                return types[i];\r\n            }\r\n        }\r\n\r\n        return types[0];\r\n    }\r\n\r\n    setPowerupProperties() {\r\n        this.name = this.config.name;\r\n        this.powerupType = this.config.type;\r\n        this.duration = this.config.duration;\r\n        this.damageReduction = this.config.damageReduction || 0;\r\n        this.headProtection = this.config.headProtection || 0;\r\n        this.boostDamage = this.config.boostDamage || 0;\r\n        this.rarity = this.config.rarity;\r\n        this.color = this.config.color;\r\n        this.secondaryColor = this.config.secondaryColor;\r\n        this.glowColor = this.config.glowColor;\r\n        this.description = this.config.description;\r\n    }\r\n\r\n    update() {\r\n        // Floating animation\r\n        this.bobPhase += 0.05;\r\n        this.pulsePhase += 0.08;\r\n        this.animationOffset += this.rotationSpeed * 0.02;\r\n    }\r\n\r\n    draw(ctx, cameraX, cameraY) {\r\n        const screenX = this.x - cameraX;\r\n        const screenY = this.y - cameraY;\r\n\r\n        ctx.save();\r\n        ctx.translate(screenX, screenY);\r\n\r\n        // Floating effect\r\n        const bobOffset = Math.sin(this.bobPhase) * 3;\r\n        ctx.translate(0, bobOffset);\r\n\r\n        // Rotation\r\n        ctx.rotate(this.animationOffset);\r\n\r\n        // Draw weapon bubble style background\r\n        this.drawWeaponBubble(ctx);\r\n\r\n        // Draw powerup icon based on type\r\n        this.drawPowerupIcon(ctx, this.size * 0.6); // Smaller icon to fit in bubble\r\n\r\n        // Draw powerup label\r\n        this.drawPowerupLabel(ctx);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawWeaponBubble(ctx) {\r\n        const time = Date.now() * 0.001;\r\n        const pulseIntensity = 0.8 + Math.sin(this.pulsePhase) * 0.2;\r\n\r\n        // Outer glow effect\r\n        const glowSize = this.size * 2 * pulseIntensity;\r\n        const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);\r\n        glowGradient.addColorStop(0, this.glowColor + '60');\r\n        glowGradient.addColorStop(0.5, this.glowColor + '30');\r\n        glowGradient.addColorStop(1, 'transparent');\r\n\r\n        ctx.fillStyle = glowGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Main bubble with gradient\r\n        const bubbleGradient = ctx.createRadialGradient(\r\n            -this.size * 0.3, -this.size * 0.3, 0,\r\n            0, 0, this.size\r\n        );\r\n        bubbleGradient.addColorStop(0, this.color + 'FF');\r\n        bubbleGradient.addColorStop(0.7, this.secondaryColor + 'DD');\r\n        bubbleGradient.addColorStop(1, this.color + '88');\r\n\r\n        ctx.fillStyle = bubbleGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, this.size, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Bubble highlight\r\n        const highlightGradient = ctx.createRadialGradient(\r\n            -this.size * 0.4, -this.size * 0.4, 0,\r\n            -this.size * 0.2, -this.size * 0.2, this.size * 0.6\r\n        );\r\n        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');\r\n        highlightGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');\r\n        highlightGradient.addColorStop(1, 'transparent');\r\n\r\n        ctx.fillStyle = highlightGradient;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, this.size, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Bubble outline with pulsing effect\r\n        ctx.strokeStyle = this.glowColor;\r\n        ctx.lineWidth = 2 + Math.sin(time * 4 + this.pulsePhase) * 0.5;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, this.size, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n\r\n        // Energy particles around bubble\r\n        for (let i = 0; i < 6; i++) {\r\n            const particleAngle = (time * 2 + i * Math.PI / 3) % (Math.PI * 2);\r\n            const particleDistance = this.size * 1.3;\r\n            const particleX = Math.cos(particleAngle) * particleDistance;\r\n            const particleY = Math.sin(particleAngle) * particleDistance;\r\n            const particleSize = 2 + Math.sin(time * 6 + i) * 1;\r\n\r\n            ctx.fillStyle = this.glowColor + 'AA';\r\n            ctx.beginPath();\r\n            ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    drawPowerupIcon(ctx, size) {\r\n        switch (this.type) {\r\n            case 'helmet':\r\n                this.drawHelmetIcon(ctx, size);\r\n                break;\r\n            case 'forcefield':\r\n                this.drawForcefieldIcon(ctx, size);\r\n                break;\r\n            case 'armor_plating':\r\n                this.drawArmorIcon(ctx, size);\r\n                break;\r\n            case 'battering_ram':\r\n                this.drawBatteringRamIcon(ctx, size);\r\n                break;\r\n            case 'shield_generator':\r\n                this.drawShieldGeneratorIcon(ctx, size);\r\n                break;\r\n            default:\r\n                this.drawHelmetIcon(ctx, size);\r\n        }\r\n    }\r\n\r\n    drawHelmetIcon(ctx, size) {\r\n        // Combat helmet design\r\n        ctx.fillStyle = this.color;\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Main helmet dome\r\n        ctx.beginPath();\r\n        ctx.arc(0, -size * 0.2, size * 0.6, 0, Math.PI, true);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Visor\r\n        ctx.fillStyle = this.secondaryColor;\r\n        ctx.beginPath();\r\n        ctx.arc(0, -size * 0.2, size * 0.4, 0, Math.PI, true);\r\n        ctx.fill();\r\n\r\n        // Chin guard\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(-size * 0.3, size * 0.1, size * 0.6, size * 0.2);\r\n        ctx.strokeRect(-size * 0.3, size * 0.1, size * 0.6, size * 0.2);\r\n    }\r\n\r\n    drawForcefieldIcon(ctx, size) {\r\n        // Energy forcefield design\r\n        const time = Date.now() * 0.005;\r\n\r\n        // Multiple energy rings\r\n        for (let i = 0; i < 3; i++) {\r\n            const ringSize = size * (0.3 + i * 0.2);\r\n            const alpha = 0.8 - i * 0.2;\r\n\r\n            ctx.strokeStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');\r\n            ctx.lineWidth = 3 - i;\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(0, 0, ringSize + Math.sin(time + i) * 3, 0, Math.PI * 2);\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Central energy core\r\n        ctx.fillStyle = this.glowColor;\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);\r\n        ctx.fill();\r\n    }\r\n\r\n    drawArmorIcon(ctx, size) {\r\n        // Armor plating design\r\n        ctx.fillStyle = this.color;\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Main armor plate\r\n        ctx.fillRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);\r\n        ctx.strokeRect(-size * 0.4, -size * 0.4, size * 0.8, size * 0.8);\r\n\r\n        // Armor segments\r\n        for (let i = 0; i < 3; i++) {\r\n            const y = -size * 0.2 + i * size * 0.2;\r\n            ctx.strokeStyle = this.secondaryColor;\r\n            ctx.beginPath();\r\n            ctx.moveTo(-size * 0.3, y);\r\n            ctx.lineTo(size * 0.3, y);\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Rivets\r\n        for (let x = -1; x <= 1; x += 2) {\r\n            for (let y = -1; y <= 1; y += 2) {\r\n                ctx.fillStyle = this.secondaryColor;\r\n                ctx.beginPath();\r\n                ctx.arc(x * size * 0.25, y * size * 0.25, size * 0.05, 0, Math.PI * 2);\r\n                ctx.fill();\r\n            }\r\n        }\r\n    }\r\n\r\n    drawBatteringRamIcon(ctx, size) {\r\n        // Battering ram design\r\n        ctx.fillStyle = this.color;\r\n        ctx.strokeStyle = this.secondaryColor;\r\n        ctx.lineWidth = 2;\r\n\r\n        // Ram head (pointed)\r\n        ctx.beginPath();\r\n        ctx.moveTo(size * 0.4, 0);\r\n        ctx.lineTo(-size * 0.2, -size * 0.3);\r\n        ctx.lineTo(-size * 0.4, -size * 0.1);\r\n        ctx.lineTo(-size * 0.4, size * 0.1);\r\n        ctx.lineTo(-size * 0.2, size * 0.3);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Impact spikes\r\n        for (let i = 0; i < 3; i++) {\r\n            const angle = (i - 1) * 0.3;\r\n            const x = Math.cos(angle) * size * 0.3;\r\n            const y = Math.sin(angle) * size * 0.3;\r\n\r\n            ctx.fillStyle = this.secondaryColor;\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, size * 0.08, 0, Math.PI * 2);\r\n            ctx.fill();\r\n        }\r\n    }\r\n\r\n    drawShieldGeneratorIcon(ctx, size) {\r\n        // Shield generator design\r\n        const time = Date.now() * 0.008;\r\n\r\n        // Generator core\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(-size * 0.2, -size * 0.2, size * 0.4, size * 0.4);\r\n\r\n        // Energy projectors\r\n        for (let i = 0; i < 4; i++) {\r\n            const angle = i * Math.PI * 0.5;\r\n            const x = Math.cos(angle) * size * 0.3;\r\n            const y = Math.sin(angle) * size * 0.3;\r\n\r\n            ctx.save();\r\n            ctx.translate(x, y);\r\n            ctx.rotate(angle);\r\n\r\n            ctx.fillStyle = this.secondaryColor;\r\n            ctx.fillRect(-size * 0.05, -size * 0.1, size * 0.1, size * 0.2);\r\n            ctx.restore();\r\n        }\r\n\r\n        // Animated shield dome\r\n        ctx.strokeStyle = this.glowColor + '80';\r\n        ctx.lineWidth = 2;\r\n        ctx.setLineDash([5, 5]);\r\n        ctx.lineDashOffset = time * 10;\r\n\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n\r\n        ctx.setLineDash([]);\r\n    }\r\n\r\n    drawPowerupLabel(ctx) {\r\n        // Get short label for powerup type\r\n        const labels = {\r\n            'helmet': 'HELMET',\r\n            'forcefield': 'SHIELD',\r\n            'armor_plating': 'ARMOR',\r\n            'battering_ram': 'RAM',\r\n            'shield_generator': 'GENERATOR'\r\n        };\r\n\r\n        const label = labels[this.type] || 'POWERUP';\r\n\r\n        // Position label below the bubble\r\n        const labelY = this.size + 15;\r\n\r\n        ctx.save();\r\n\r\n        // Text styling\r\n        ctx.font = 'bold 8px monospace';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        // Text background for better readability\r\n        const textWidth = ctx.measureText(label).width;\r\n        const padding = 3;\r\n        const bgWidth = textWidth + padding * 2;\r\n        const bgHeight = 10;\r\n\r\n        // Background with slight transparency\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n        ctx.fillRect(-bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);\r\n\r\n        // Border around background\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(-bgWidth / 2, labelY - bgHeight / 2, bgWidth, bgHeight);\r\n\r\n        // Text with powerup color\r\n        ctx.fillStyle = this.glowColor;\r\n        ctx.fillText(label, 0, labelY);\r\n\r\n        // Add small glow effect to text\r\n        ctx.shadowColor = this.glowColor;\r\n        ctx.shadowBlur = 2;\r\n        ctx.fillText(label, 0, labelY);\r\n\r\n        ctx.restore();\r\n    }\r\n}\r\n\r\nclass Game {\r\n    constructor(canvas, gameMode = 'classic') {\r\n        console.log('Game constructor started');\r\n\r\n        this.canvas = canvas;\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.minimap = null;\r\n        this.minimapCtx = null;\r\n\r\n        // Canvas setup - size to container\r\n        const resizeCanvas = () => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            const newWidth = rect.width || window.innerWidth;\r\n            const newHeight = rect.height || window.innerHeight;\r\n\r\n            if (newWidth > 0 && newHeight > 0) {\r\n                this.canvas.width = newWidth;\r\n                this.canvas.height = newHeight;\r\n                console.log('Canvas resized to:', this.canvas.width, 'x', this.canvas.height);\r\n            } else {\r\n                console.log('Canvas size invalid:', newWidth, 'x', newHeight, 'rect:', rect);\r\n            }\r\n        };\r\n\r\n        // Store resize function for cleanup\r\n        this.resizeCanvas = resizeCanvas;\r\n\r\n        // Initial resize with multiple attempts\r\n        setTimeout(resizeCanvas, 50);\r\n        setTimeout(resizeCanvas, 200);\r\n        setTimeout(resizeCanvas, 500);\r\n\r\n        // Handle window resize\r\n        window.addEventListener('resize', resizeCanvas);\r\n\r\n        // Game world dimensions\r\n        this.worldWidth = 4000;\r\n        this.worldHeight = 4000;\r\n\r\n        // Game mode\r\n        this.gameMode = gameMode;\r\n\r\n        // Warfare mode properties\r\n        this.weapons = [];\r\n        this.ammo = []; // Separate ammo pickups\r\n        this.powerups = []; // Defensive and offensive powerups\r\n        this.projectiles = []; // Projectiles fired by snakes\r\n        this.coins = []; // Collectible coins from damaged segments\r\n\r\n        // Gambling system\r\n        this.playerWager = 0; // Player's selected wager amount\r\n        this.availableWagers = [10, 25, 50, 100, 250, 500]; // Available wager options\r\n\r\n        // Weapon inventory system\r\n        this.weaponInventory = {\r\n            primaryWeapon: null,\r\n            secondaryWeapon: null,\r\n            sidearm: new Weapon(0, 0, 'sidearm'), // Always available\r\n            currentSlot: 'sidearm'\r\n        };\r\n        this.currentWeapon = this.weaponInventory.sidearm;\r\n        this.lastWeaponSlot = 'sidearm'; // For quick switching\r\n\r\n        // Ammo inventory tracking\r\n        this.ammoInventory = {\r\n            light_energy: 0,\r\n            heavy_energy: 0,\r\n            plasma_cells: 0,\r\n            heavy_plasma: 0,\r\n            rockets: 0,\r\n            rail_slugs: 0\r\n        };\r\n\r\n        // Game state\r\n        this.gameRunning = true;\r\n        this.score = 0;\r\n        this.cashBalance = 0; // Separate cash balance for warfare mode\r\n        this.camera = { x: 1500, y: 1500 }; // Start camera in middle of world\r\n        this.currentKing = null; // Track the snake with highest balance\r\n\r\n        // Game objects\r\n        this.player = new Snake(2000, 2000, '#FFD700', true); // Golden yellow color\r\n        this.player.gameInstance = this; // Set game reference\r\n\r\n        // Set default player wager for both modes (gambling mechanics in both)\r\n        this.playerWager = 50; // Default $50 wager\r\n        this.player.wager = this.playerWager;\r\n        // Give player starting cash equal to their wager\r\n        this.cashBalance = this.playerWager;\r\n\r\n        // Activate spawn invincibility for player\r\n        this.player.activateSpawnInvincibility(this.playerWager);\r\n\r\n        // Log initial player state for debugging\r\n        console.log('Initial player setup - segments:', this.player.segments.length, 'cash balance: $' + this.cashBalance);\r\n\r\n        if (this.gameMode === 'classic') {\r\n            // In classic mode, score is separate from cash\r\n            this.score = 0;\r\n        } else {\r\n            // In warfare mode, score equals cash\r\n            this.score = this.cashBalance;\r\n        }\r\n\r\n        // Multiplayer system - replace AI snakes with remote players\r\n        this.remotePlayers = []; // Other players in the same room\r\n        this.isMultiplayer = true; // Enable multiplayer mode\r\n        this.roomId = null; // Current room ID\r\n        this.playerId = null; // This player's unique ID\r\n        this.realtimeChannel = null; // Supabase realtime channel\r\n        this.multiplayerService = null; // Reference to multiplayer service\r\n\r\n        this.aiSnakes = []; // Keep for compatibility but won't be used in multiplayer\r\n        this.food = [];\r\n        this.glowOrbs = [];\r\n\r\n        // Weapons system (warfare mode only)\r\n        this.weapons = [];\r\n        this.ammo = [];\r\n        this.powerups = [];\r\n        this.projectiles = [];\r\n        this.coins = []; // For gambling mechanics in both modes\r\n\r\n        // Input handling\r\n        this.mouse = { x: this.canvas.width / 2, y: this.canvas.height / 2 };\r\n        this.boosting = false;\r\n        this.mouseHeld = false; // Track if mouse is held down for full auto\r\n\r\n        // Generate initial game objects\r\n        this.generateFood();\r\n        this.generateGlowOrbs();\r\n\r\n        // React integration\r\n        this.onStateUpdate = null;\r\n        this.onGameOver = null;\r\n\r\n        // Cashout system\r\n        this.cashedOut = false;\r\n        this.spectating = false;\r\n        this.spectateTarget = 0; // Index of snake being spectated\r\n        this.cashoutBalance = 0; // Final cashed out amount\r\n\r\n        // DON'T auto-initialize - wait for explicit start() call to ensure callbacks are set up\r\n        console.log('Game constructor completed - waiting for start() call');\r\n    }\r\n\r\n    init() {\r\n        console.log('Initializing multiplayer game...');\r\n\r\n        // MULTIPLAYER MODE: No AI snakes - only real players\r\n        console.log('🌐 Multiplayer mode enabled - AI snakes disabled');\r\n        console.log('🎮 Waiting for other players to join the room...');\r\n\r\n        // Initialize warfare mode if selected\r\n        if (this.gameMode === 'warfare') {\r\n            // Generate initial weapons\r\n            for (let i = 0; i < 5; i++) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.weapons.push(new Weapon(x, y));\r\n            }\r\n\r\n            // Generate initial ammo\r\n            for (let i = 0; i < 15; i++) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.ammo.push(new Ammo(x, y));\r\n            }\r\n\r\n            // Generate initial powerups\r\n            for (let i = 0; i < 8; i++) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.powerups.push(new Powerup(x, y));\r\n            }\r\n        }\r\n\r\n        // Add to Game class update method\r\n        if (this.gameMode === 'warfare') {\r\n            // Update weapons\r\n            this.weapons = this.weapons.filter(weapon => !weapon.collected);\r\n\r\n            // Generate new weapons if needed\r\n            while (this.weapons.length < 5) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.weapons.push(new Weapon(x, y));\r\n            }\r\n\r\n            // Weapon UI will be updated through React state callback\r\n        }\r\n\r\n        // Reset game state (but keep player from constructor)\r\n        this.gameRunning = true;\r\n        this.score = this.gameMode === 'warfare' ? this.cashBalance : 0;\r\n        this.camera = { x: 1500, y: 1500 }; // Start camera in middle of world\r\n\r\n        // Reset game objects (but keep player and aiSnakes from constructor)\r\n        // DON'T reset player or aiSnakes here - they were already created above!\r\n        this.food = [];\r\n        this.glowOrbs = [];\r\n\r\n        // Input handling\r\n        this.mouse = { x: this.canvas.width / 2, y: this.canvas.height / 2 };\r\n        this.boosting = false;\r\n\r\n        // Initialize gamepad support\r\n        this.initializeGamepadSupport();\r\n\r\n        // Generate initial game objects\r\n        this.generateFood();\r\n        this.generateGlowOrbs();\r\n    }\r\n\r\n    generateFood() {\r\n        console.log('Generating food...');\r\n        // Generate more food in warfare mode for speed boost mechanics\r\n        const foodCount = this.gameMode === 'warfare' ? 1000 : 500; // Double food in warfare mode\r\n\r\n        for (let i = 0; i < foodCount; i++) {\r\n            this.food.push({\r\n                x: Math.random() * this.worldWidth,\r\n                y: Math.random() * this.worldHeight,\r\n                color: `hsl(${Math.random() * 360}, 70%, 60%)`,\r\n                size: 4 + Math.random() * 3\r\n            });\r\n        }\r\n        console.log(`Generated ${this.food.length} food items for ${this.gameMode} mode`);\r\n    }\r\n\r\n    generateGlowOrbs() {\r\n        console.log('Generating glow orbs...');\r\n        for (let i = 0; i < 10; i++) {\r\n            const hue = Math.random() * 360;\r\n            this.glowOrbs.push({\r\n                x: Math.random() * this.worldWidth,\r\n                y: Math.random() * this.worldHeight,\r\n                vx: (Math.random() - 0.5) * 2,\r\n                vy: (Math.random() - 0.5) * 2,\r\n                hue: hue,\r\n                size: 8 + Math.random() * 4,\r\n                glow: 0,\r\n                value: 5\r\n            });\r\n        }\r\n        console.log(`Generated ${this.glowOrbs.length} glow orbs`);\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // Mouse movement\r\n        this.canvas.addEventListener('mousemove', (e) => {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            this.mouse.x = e.clientX - rect.left;\r\n            this.mouse.y = e.clientY - rect.top;\r\n        });\r\n\r\n        // Mouse controls\r\n        this.canvas.addEventListener('mousedown', (e) => {\r\n            if (e.button === 0) {\r\n                // Left click - shoot in warfare mode (only if not invincible), boost in classic mode\r\n                if (this.gameMode === 'warfare' && this.currentWeapon && !this.player.isInvincible()) {\r\n                    this.mouseHeld = true;\r\n                    this.shoot();\r\n                } else {\r\n                    this.boosting = true;\r\n                }\r\n            } else if (e.button === 2) {\r\n                // Right click - always boost\r\n                this.boosting = true;\r\n            }\r\n        });\r\n\r\n        this.canvas.addEventListener('mouseup', (e) => {\r\n            if (e.button === 0) {\r\n                // Left click release\r\n                this.mouseHeld = false;\r\n                if (this.gameMode !== 'warfare') {\r\n                    this.boosting = false;\r\n                }\r\n            } else if (e.button === 2) {\r\n                // Right click release - stop boost\r\n                this.boosting = false;\r\n            }\r\n        });\r\n\r\n        // Disable right-click context menu\r\n        this.canvas.addEventListener('contextmenu', (e) => {\r\n            e.preventDefault();\r\n        });\r\n\r\n        document.addEventListener('keydown', (e) => {\r\n            if (e.code === 'Space') {\r\n                e.preventDefault();\r\n                if (this.gameMode === 'warfare' && this.currentWeapon && !this.player.isInvincible()) {\r\n                    this.shoot();\r\n                } else {\r\n                    this.boosting = true;\r\n                }\r\n            }\r\n\r\n            // Cashout hotkey (both modes)\r\n            if (e.code === 'KeyC') {\r\n                e.preventDefault();\r\n                this.cashOut();\r\n            }\r\n\r\n            // Spectate cycling (when spectating)\r\n            if (e.code === 'Tab' && this.spectating) {\r\n                e.preventDefault();\r\n                this.cycleThroughSnakes();\r\n            }\r\n\r\n            // Weapon switching (warfare mode only)\r\n            if (this.gameMode === 'warfare') {\r\n                switch (e.code) {\r\n                    case 'Digit1':\r\n                        this.switchToWeapon('primaryWeapon');\r\n                        break;\r\n                    case 'Digit2':\r\n                        this.switchToWeapon('secondaryWeapon');\r\n                        break;\r\n                    case 'Digit3':\r\n                        this.switchToWeapon('sidearm');\r\n                        break;\r\n                    case 'KeyQ':\r\n                        this.quickSwitchWeapon();\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n\r\n        document.addEventListener('keyup', (e) => {\r\n            if (e.code === 'Space') {\r\n                e.preventDefault();\r\n                this.boosting = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    // Weapon switching methods\r\n    switchToWeapon(slot) {\r\n        const weapon = this.weaponInventory[slot];\r\n\r\n        if (weapon && (weapon.currentAmmo > 0 || weapon.maxAmmo === Infinity)) {\r\n            this.lastWeaponSlot = this.weaponInventory.currentSlot;\r\n            this.weaponInventory.currentSlot = slot;\r\n            this.currentWeapon = weapon;\r\n        }\r\n    }\r\n\r\n    quickSwitchWeapon() {\r\n        if (this.lastWeaponSlot && this.weaponInventory[this.lastWeaponSlot]) {\r\n            const temp = this.weaponInventory.currentSlot;\r\n            this.switchToWeapon(this.lastWeaponSlot);\r\n            this.lastWeaponSlot = temp;\r\n        }\r\n    }\r\n\r\n    addWeaponToInventory(weapon) {\r\n        // Try to add to primary slot first, then secondary\r\n        if (!this.weaponInventory.primaryWeapon) {\r\n            this.weaponInventory.primaryWeapon = weapon;\r\n            this.switchToWeapon('primaryWeapon');\r\n        } else if (!this.weaponInventory.secondaryWeapon) {\r\n            this.weaponInventory.secondaryWeapon = weapon;\r\n            this.switchToWeapon('secondaryWeapon');\r\n        } else {\r\n            // Replace current weapon\r\n            const currentSlot = this.weaponInventory.currentSlot;\r\n            if (currentSlot !== 'sidearm') {\r\n                this.weaponInventory[currentSlot] = weapon;\r\n                this.currentWeapon = weapon;\r\n            } else {\r\n                // If sidearm is active, replace primary\r\n                this.weaponInventory.primaryWeapon = weapon;\r\n                this.switchToWeapon('primaryWeapon');\r\n            }\r\n        }\r\n    }\r\n\r\n    getAmmoInventory() {\r\n        // Return only ammo types that have non-zero amounts\r\n        const nonZeroAmmo = {};\r\n        Object.entries(this.ammoInventory).forEach(([type, amount]) => {\r\n            if (amount > 0) {\r\n                nonZeroAmmo[type] = amount;\r\n            }\r\n        });\r\n        return nonZeroAmmo;\r\n    }\r\n\r\n    reloadWeaponsFromInventory() {\r\n        // Try to reload all weapons from ammo inventory\r\n        ['primaryWeapon', 'secondaryWeapon', 'sidearm'].forEach(slot => {\r\n            const weapon = this.weaponInventory[slot];\r\n            if (weapon && weapon.ammoTypes.length > 0) {\r\n                // Try each compatible ammo type\r\n                weapon.ammoTypes.forEach(ammoType => {\r\n                    if (this.ammoInventory[ammoType] > 0 && weapon.currentAmmo < weapon.maxAmmo) {\r\n                        const ammoNeeded = weapon.maxAmmo - weapon.currentAmmo;\r\n                        const ammoToUse = Math.min(this.ammoInventory[ammoType], ammoNeeded);\r\n\r\n                        weapon.currentAmmo += ammoToUse;\r\n                        this.ammoInventory[ammoType] -= ammoToUse;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    reloadAIWeaponsFromInventory(snake) {\r\n        if (!snake.weaponInventory || !snake.ammoInventory) return;\r\n\r\n        // Try to reload all AI weapons from ammo inventory\r\n        ['primaryWeapon', 'secondaryWeapon', 'sidearm'].forEach(slot => {\r\n            const weapon = snake.weaponInventory[slot];\r\n            if (weapon && weapon.ammoTypes.length > 0) {\r\n                // Try each compatible ammo type\r\n                weapon.ammoTypes.forEach(ammoType => {\r\n                    if (snake.ammoInventory[ammoType] > 0 && weapon.currentAmmo < weapon.maxAmmo) {\r\n                        const ammoNeeded = weapon.maxAmmo - weapon.currentAmmo;\r\n                        const ammoToUse = Math.min(snake.ammoInventory[ammoType], ammoNeeded);\r\n\r\n                        weapon.currentAmmo += ammoToUse;\r\n                        snake.ammoInventory[ammoType] -= ammoToUse;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    shoot() {\r\n        if (!this.currentWeapon) return;\r\n\r\n        // Check if weapon can shoot (ammo and cooldown)\r\n        if (!this.currentWeapon.canShoot()) return;\r\n\r\n        const worldMouseX = this.mouse.x + this.camera.x;\r\n        const worldMouseY = this.mouse.y + this.camera.y;\r\n        const playerHead = this.player.segments[0];\r\n\r\n        // Calculate shot direction\r\n        const dx = worldMouseX - playerHead.x;\r\n        const dy = worldMouseY - playerHead.y;\r\n        const angle = Math.atan2(dy, dx);\r\n\r\n        // Store weapon reference before shooting (in case it changes)\r\n        const weaponUsed = this.currentWeapon;\r\n        const firingMode = weaponUsed.config.firingMode || 'semi_auto';\r\n\r\n        // Handle different firing modes\r\n        switch (firingMode) {\r\n            case 'tri_burst_sequential':\r\n                this.handleSequentialBurst(weaponUsed, angle, playerHead);\r\n                break;\r\n            case 'tri_burst_spread':\r\n                this.handleSpreadBurst(weaponUsed, angle, playerHead);\r\n                break;\r\n            case 'full_auto':\r\n            case 'semi_auto':\r\n            default:\r\n                this.createProjectile(weaponUsed, angle, playerHead);\r\n                break;\r\n        }\r\n\r\n        // Switch to sidearm if current weapon is out of ammo\r\n        if (weaponUsed.currentAmmo <= 0 && weaponUsed.type !== 'sidearm') {\r\n            this.switchToWeapon('sidearm');\r\n        }\r\n    }\r\n\r\n    handleSequentialBurst(weapon, angle, playerHead) {\r\n        const now = Date.now();\r\n\r\n        if (!weapon.burstState.inBurst) {\r\n            // Start new burst\r\n            weapon.burstState.inBurst = true;\r\n            weapon.burstState.shotsInBurst = 0;\r\n        }\r\n\r\n        // Fire shot\r\n        this.createProjectile(weapon, angle, playerHead);\r\n        weapon.burstState.shotsInBurst++;\r\n        weapon.burstState.lastBurstShotTime = now;\r\n\r\n        // Check if burst is complete\r\n        if (weapon.burstState.shotsInBurst >= (weapon.config.burstCount || 3)) {\r\n            weapon.burstState.inBurst = false;\r\n            weapon.burstState.shotsInBurst = 0;\r\n            weapon.burstState.burstCooldownStart = now;\r\n        }\r\n    }\r\n\r\n    handleSpreadBurst(weapon, angle, playerHead) {\r\n        const burstCount = weapon.config.burstCount || 3;\r\n        const spreadAngle = weapon.config.spreadAngle || 0.3;\r\n\r\n        // Fire multiple projectiles at once with spread\r\n        for (let i = 0; i < burstCount; i++) {\r\n            const offset = (i - Math.floor(burstCount / 2)) * spreadAngle;\r\n            const shotAngle = angle + offset;\r\n            this.createProjectile(weapon, shotAngle, playerHead);\r\n        }\r\n    }\r\n\r\n    createProjectile(weapon, angle, playerHead) {\r\n        // Use ammo from weapon\r\n        if (!weapon.shoot()) return;\r\n\r\n        // Create projectile with enhanced properties\r\n        const projectile = {\r\n            x: playerHead.x,\r\n            y: playerHead.y,\r\n            vx: Math.cos(angle) * weapon.projectileSpeed,\r\n            vy: Math.sin(angle) * weapon.projectileSpeed,\r\n            type: weapon.type,\r\n            damage: weapon.damage,\r\n            owner: this.player, // Add owner for friendly fire prevention\r\n            // Enhanced animation properties\r\n            angle: angle,\r\n            creationTime: Date.now(),\r\n            trail: [], // For trail effects\r\n            animationOffset: Math.random() * Math.PI * 2,\r\n            // Tracer round properties for minigun\r\n            isTracer: weapon.config.tracerRounds || false\r\n        };\r\n\r\n        // Add projectile to game\r\n        if (!this.projectiles) this.projectiles = [];\r\n        this.projectiles.push(projectile);\r\n    }\r\n\r\n    handleFullAutoFiring() {\r\n        // Only fire if mouse is held down and we have a weapon\r\n        if (!this.mouseHeld || !this.currentWeapon || this.gameMode !== 'warfare') return;\r\n\r\n        const firingMode = this.currentWeapon.config.firingMode || 'semi_auto';\r\n\r\n        // Only handle full auto weapons here\r\n        if (firingMode === 'full_auto' && this.currentWeapon.canShoot()) {\r\n            this.shoot();\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (!this.gameRunning) return;\r\n\r\n        // Handle full auto firing\r\n        this.handleFullAutoFiring();\r\n\r\n        // Update player\r\n        this.updatePlayer();\r\n\r\n        // Update remote players (multiplayer)\r\n        this.updateRemotePlayers();\r\n\r\n        // Update glow orbs\r\n        this.updateGlowOrbs();\r\n\r\n        // Check collisions\r\n        this.checkCollisions();\r\n\r\n        // Update camera\r\n        this.updateCamera();\r\n\r\n        // Update king status\r\n        this.updateKing();\r\n\r\n        // Update coins (gambling mechanics in both modes)\r\n        this.updateCoins();\r\n\r\n        // Update UI\r\n        this.updateGameState();\r\n\r\n        // Warfare mode updates\r\n        if (this.gameMode === 'warfare') {\r\n            // Update weapons\r\n            this.weapons = this.weapons.filter(weapon => !weapon.collected);\r\n\r\n            // Generate new weapons if needed\r\n            while (this.weapons.length < 5) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.weapons.push(new Weapon(x, y));\r\n            }\r\n\r\n            // Update ammo\r\n            this.ammo = this.ammo.filter(ammo => !ammo.collected);\r\n\r\n            // Generate new ammo if needed\r\n            while (this.ammo.length < 15) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.ammo.push(new Ammo(x, y));\r\n            }\r\n\r\n            // Update powerups\r\n            this.powerups = this.powerups.filter(powerup => !powerup.collected);\r\n\r\n            // Generate new powerups if needed\r\n            while (this.powerups.length < 8) {\r\n                const x = Math.random() * this.worldWidth;\r\n                const y = Math.random() * this.worldHeight;\r\n                this.powerups.push(new Powerup(x, y));\r\n            }\r\n\r\n            // Update powerup animations\r\n            this.powerups.forEach(powerup => {\r\n                if (!powerup.collected) {\r\n                    powerup.update();\r\n                }\r\n            });\r\n\r\n            // Check weapon collisions (all snakes in warfare mode)\r\n            if (this.gameMode === 'warfare') {\r\n                const allSnakes = [this.player, ...this.aiSnakes].filter(s => s.alive);\r\n\r\n                this.weapons.forEach(weapon => {\r\n                    if (!weapon.collected) {\r\n                        allSnakes.forEach(snake => {\r\n                            const dx = snake.segments[0].x - weapon.x;\r\n                            const dy = snake.segments[0].y - weapon.y;\r\n                            const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                            if (distance < snake.size + weapon.size) {\r\n                                weapon.collected = true;\r\n                                if (snake.isPlayer) {\r\n                                    this.addWeaponToInventory(weapon);\r\n                                } else {\r\n                                    snake.addWeaponToInventory(weapon);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n\r\n                // Check ammo collisions (all snakes in warfare mode)\r\n                this.ammo.forEach(ammoItem => {\r\n                    if (!ammoItem.collected) {\r\n                        allSnakes.forEach(snake => {\r\n                            const dx = snake.segments[0].x - ammoItem.x;\r\n                            const dy = snake.segments[0].y - ammoItem.y;\r\n                            const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                            if (distance < snake.size + ammoItem.size) {\r\n                                ammoItem.collected = true;\r\n\r\n                                if (snake.isPlayer) {\r\n                                    // Add ammo to player inventory\r\n                                    this.ammoInventory[ammoItem.type] = (this.ammoInventory[ammoItem.type] || 0) + ammoItem.amount;\r\n                                    this.reloadWeaponsFromInventory();\r\n                                } else {\r\n                                    // Add ammo to AI inventory\r\n                                    snake.ammoInventory[ammoItem.type] = (snake.ammoInventory[ammoItem.type] || 0) + ammoItem.amount;\r\n                                    this.reloadAIWeaponsFromInventory(snake);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n\r\n                // Check powerup collisions (all snakes in warfare mode)\r\n                this.powerups.forEach(powerupItem => {\r\n                    if (!powerupItem.collected) {\r\n                        allSnakes.forEach(snake => {\r\n                            const dx = snake.segments[0].x - powerupItem.x;\r\n                            const dy = snake.segments[0].y - powerupItem.y;\r\n                            const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                            if (distance < snake.size + powerupItem.size) {\r\n                                powerupItem.collected = true;\r\n\r\n                                // Add powerup to snake's inventory\r\n                                snake.addPowerup(powerupItem);\r\n\r\n                                // For player, automatically activate defensive powerups\r\n                                if (snake.isPlayer && powerupItem.powerupType === 'defensive') {\r\n                                    snake.activatePowerup(powerupItem.type);\r\n                                }\r\n                                // For AI, activate powerups based on situation\r\n                                else if (!snake.isPlayer) {\r\n                                    // AI automatically activates powerups\r\n                                    snake.activatePowerup(powerupItem.type);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Update and check projectiles\r\n            if (this.projectiles) {\r\n                this.projectiles = this.projectiles.filter(projectile => {\r\n                    // Initialize trail if it doesn't exist\r\n                    if (!projectile.trail) {\r\n                        projectile.trail = [];\r\n                    }\r\n\r\n                    // Update trail for visual effects\r\n                    projectile.trail.push({ x: projectile.x, y: projectile.y, time: Date.now() });\r\n\r\n                    // Keep trail length manageable\r\n                    if (projectile.trail.length > 10) {\r\n                        projectile.trail.shift();\r\n                    }\r\n\r\n                    // Update position\r\n                    projectile.x += projectile.vx;\r\n                    projectile.y += projectile.vy;\r\n\r\n                    // Check if projectile is out of bounds\r\n                    if (projectile.x < 0 || projectile.x > this.worldWidth ||\r\n                        projectile.y < 0 || projectile.y > this.worldHeight) {\r\n                        return false;\r\n                    }\r\n\r\n                    // Check collisions with snakes\r\n                    const allSnakes = [this.player, ...this.aiSnakes].filter(s => s.alive);\r\n                    for (const snake of allSnakes) {\r\n                        // Skip collision with projectile owner (no friendly fire)\r\n                        if (snake === projectile.owner) {\r\n                            continue;\r\n                        }\r\n\r\n                        // Check if snake is invincible\r\n                        // Remote players don't have isInvincible method\r\n                        const isInvincible = (typeof snake.isInvincible === 'function') ? snake.isInvincible() : (snake.isInvincible || false);\r\n                        if (isInvincible) {\r\n                            console.log('Projectile hit invincible snake, no damage dealt');\r\n                            continue; // Skip damage for invincible snakes\r\n                        }\r\n\r\n                        // Check head collision (instant kill with protection check)\r\n                        const headDx = snake.segments[0].x - projectile.x;\r\n                        const headDy = snake.segments[0].y - projectile.y;\r\n                        const headDist = Math.sqrt(headDx * headDx + headDy * headDy);\r\n\r\n                        if (headDist < snake.size) {\r\n                            // Check for helmet protection first\r\n                            const helmetDamageResult = snake.damageHelmet(projectile.damage * 25);\r\n\r\n                            if (helmetDamageResult !== null) {\r\n                                // Helmet absorbed the damage\r\n                                if (helmetDamageResult) {\r\n                                    // Helmet was destroyed, show visual effect\r\n                                    console.log(\"Helmet destroyed!\");\r\n                                }\r\n                                return false; // Projectile absorbed by helmet\r\n                            }\r\n\r\n                            // No helmet or helmet destroyed, check other head protection\r\n                            const headProtection = snake.getHeadProtection();\r\n                            const survives = Math.random() < headProtection;\r\n\r\n                            if (survives) {\r\n                                // Snake survives headshot due to protection\r\n                                // Apply reduced damage to head segment instead\r\n                                const reducedDamage = projectile.damage * 10; // Much less than normal segment damage\r\n                                snake.segments[0].health -= reducedDamage;\r\n\r\n                                if (snake.segments[0].health <= 0) {\r\n                                    // Head destroyed despite protection\r\n                                    this.convertSnakeToCoins(snake);\r\n                                    snake.alive = false;\r\n                                    if (snake.isPlayer) {\r\n                                        this.gameOver();\r\n                                    }\r\n                                }\r\n                                return false;\r\n                            } else {\r\n                                // Normal headshot - convert entire snake to coins\r\n                                this.convertSnakeToCoins(snake);\r\n                                snake.alive = false;\r\n\r\n                                // Check if player died for game over\r\n                                if (snake.isPlayer) {\r\n                                    this.gameOver(); // Call gameOver() method to show game over screen\r\n                                }\r\n\r\n                                return false;\r\n                            }\r\n                        }\r\n\r\n                        // Check body collision (segment damage system)\r\n                        let hitSegment = false;\r\n                        for (let i = 1; i < snake.segments.length; i++) {\r\n                            const segment = snake.segments[i];\r\n                            const dx = segment.x - projectile.x;\r\n                            const dy = segment.y - projectile.y;\r\n                            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                            if (dist < snake.size) {\r\n                                // Apply damage reduction from defensive powerups\r\n                                const damageReduction = snake.getDamageReduction();\r\n                                const baseDamage = projectile.damage * 25; // Scale damage for health system\r\n                                const finalDamage = baseDamage * (1 - damageReduction);\r\n\r\n                                segment.health -= finalDamage;\r\n\r\n                                // If segment health reaches 0, break it off\r\n                                if (segment.health <= 0) {\r\n                                    this.breakOffSegments(snake, i, projectile.owner);\r\n                                }\r\n\r\n                                hitSegment = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (hitSegment) return false;\r\n                    }\r\n\r\n                    return true;\r\n                });\r\n            }\r\n\r\n            // Weapon UI will be updated through React state callback\r\n        }\r\n    }\r\n\r\n    updatePlayer() {\r\n        if (!this.player.alive) return;\r\n\r\n        // Calculate target direction based on mouse position\r\n        const worldMouseX = this.mouse.x + this.camera.x;\r\n        const worldMouseY = this.mouse.y + this.camera.y;\r\n\r\n        const dx = worldMouseX - this.player.x;\r\n        const dy = worldMouseY - this.player.y;\r\n        const angle = Math.atan2(dy, dx);\r\n\r\n        this.player.targetAngle = angle;\r\n        this.player.update(this.boosting);\r\n    }\r\n\r\n    updateAISnake(snake) {\r\n        if (!snake.alive) return;\r\n\r\n        if (this.gameMode === 'warfare') {\r\n            this.updateWarfareAI(snake);\r\n        } else {\r\n            this.updateClassicAI(snake);\r\n        }\r\n    }\r\n\r\n    updateClassicAI(snake) {\r\n        // Simple AI: move towards nearest coins, food, or away from threats\r\n        let targetX = snake.x;\r\n        let targetY = snake.y;\r\n        let minDist = Infinity;\r\n        let targetType = 'none';\r\n\r\n        // Find nearest coins (high priority for cash)\r\n        if (this.coins) {\r\n            this.coins.forEach(coin => {\r\n                if (coin.collected) return;\r\n                const dist = Math.hypot(coin.x - snake.x, coin.y - snake.y);\r\n                if (dist < minDist && dist < 200) {\r\n                    minDist = dist;\r\n                    targetX = coin.x;\r\n                    targetY = coin.y;\r\n                    targetType = 'coin';\r\n                }\r\n            });\r\n        }\r\n\r\n        // Find nearest food (lower priority than coins)\r\n        if (targetType === 'none') {\r\n            this.food.forEach(food => {\r\n                const dist = Math.hypot(food.x - snake.x, food.y - snake.y);\r\n                if (dist < minDist && dist < 150) {\r\n                    minDist = dist;\r\n                    targetX = food.x;\r\n                    targetY = food.y;\r\n                    targetType = 'food';\r\n                }\r\n            });\r\n        }\r\n\r\n        // Find nearest glow orbs (for boost)\r\n        if (targetType === 'none') {\r\n            this.glowOrbs.forEach(orb => {\r\n                const dist = Math.hypot(orb.x - snake.x, orb.y - snake.y);\r\n                if (dist < minDist && dist < 180) {\r\n                    minDist = dist;\r\n                    targetX = orb.x;\r\n                    targetY = orb.y;\r\n                    targetType = 'orb';\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for threats (other snakes including player)\r\n        const threats = [this.player, ...this.aiSnakes].filter(s => s !== snake && s.alive);\r\n        threats.forEach(threat => {\r\n            const dist = Math.hypot(threat.x - snake.x, threat.y - snake.y);\r\n            if (dist < 80) {\r\n                // Move away from threat\r\n                targetX = snake.x - (threat.x - snake.x);\r\n                targetY = snake.y - (threat.y - snake.y);\r\n                targetType = 'flee';\r\n            }\r\n        });\r\n\r\n        // Calculate direction\r\n        const dx = targetX - snake.x;\r\n        const dy = targetY - snake.y;\r\n        if (Math.hypot(dx, dy) > 0) {\r\n            snake.targetAngle = Math.atan2(dy, dx);\r\n        } else {\r\n            // Random movement if no target\r\n            snake.targetAngle += (Math.random() - 0.5) * 0.3;\r\n        }\r\n\r\n        // Boost when chasing coins or fleeing\r\n        const shouldBoost = (targetType === 'coin' || targetType === 'flee') && snake.boost > 30;\r\n        snake.update(shouldBoost);\r\n    }\r\n\r\n    updateWarfareAI(snake) {\r\n        const now = Date.now();\r\n\r\n        // Decision making frequency (AI thinks every 100-300ms based on personality)\r\n        if (now - snake.lastDecisionTime < snake.reactionTime) {\r\n            // Remote players don't have update method\r\n            if (typeof snake.update === 'function') {\r\n                snake.update(snake.shouldBoost);\r\n            }\r\n            return;\r\n        }\r\n        snake.lastDecisionTime = now;\r\n\r\n        // Assess situation\r\n        const situation = this.assessSituation(snake);\r\n\r\n        // State machine for AI behavior\r\n        this.updateAICombatState(snake, situation);\r\n\r\n        // Execute behavior based on current state\r\n        const action = this.executeAIBehavior(snake, situation);\r\n\r\n        // Apply movement and actions\r\n        if (action.targetX !== undefined && action.targetY !== undefined) {\r\n            const dx = action.targetX - snake.x;\r\n            const dy = action.targetY - snake.y;\r\n            if (Math.hypot(dx, dy) > 0) {\r\n                snake.targetAngle = Math.atan2(dy, dx);\r\n            }\r\n        }\r\n\r\n        // Handle shooting (only if not invincible)\r\n        // Remote players don't have isInvincible method\r\n        const isInvincible = (typeof snake.isInvincible === 'function') ? snake.isInvincible() : (snake.isInvincible || false);\r\n        if (action.shoot && action.shootTarget && !isInvincible) {\r\n            // Remote players don't have shoot method\r\n            if (typeof snake.shoot === 'function') {\r\n                const projectile = snake.shoot(action.shootTarget.x, action.shootTarget.y);\r\n                if (projectile) {\r\n                    this.projectiles.push(projectile);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle weapon switching\r\n        if (action.switchWeapon) {\r\n            this.handleAIWeaponSwitch(snake, situation);\r\n        }\r\n\r\n        // Update snake with boost decision\r\n        snake.shouldBoost = action.boost;\r\n        // Remote players don't have update method\r\n        if (typeof snake.update === 'function') {\r\n            snake.update(action.boost);\r\n        }\r\n    }\r\n\r\n    // AI Situation Assessment\r\n    assessSituation(snake) {\r\n        const situation = {\r\n            nearbyEnemies: [],\r\n            nearbyWeapons: [],\r\n            nearbyAmmo: [],\r\n            nearbyFood: [],\r\n            nearbyOrbs: [],\r\n            nearbyCoins: [],\r\n            incomingProjectiles: [],\r\n            threatLevel: 0,\r\n            opportunityLevel: 0\r\n        };\r\n\r\n        const allEnemies = [this.player, ...this.aiSnakes].filter(s => s !== snake && s.alive);\r\n        const detectionRange = 300;\r\n\r\n        // Scan for enemies\r\n        allEnemies.forEach(enemy => {\r\n            const dist = Math.hypot(enemy.x - snake.x, enemy.y - snake.y);\r\n            if (dist < detectionRange) {\r\n                const threat = {\r\n                    snake: enemy,\r\n                    distance: dist,\r\n                    angle: Math.atan2(enemy.y - snake.y, enemy.x - snake.x),\r\n                    size: enemy.segments.length,\r\n                    hasWeapon: enemy.currentWeapon && enemy.currentWeapon.type !== 'sidearm',\r\n                    threatScore: this.calculateThreatScore(snake, enemy, dist)\r\n                };\r\n                situation.nearbyEnemies.push(threat);\r\n                situation.threatLevel += threat.threatScore;\r\n            }\r\n        });\r\n\r\n        // Scan for weapons\r\n        this.weapons.forEach(weapon => {\r\n            if (!weapon.collected) {\r\n                const dist = Math.hypot(weapon.x - snake.x, weapon.y - snake.y);\r\n                if (dist < detectionRange) {\r\n                    situation.nearbyWeapons.push({\r\n                        weapon: weapon,\r\n                        distance: dist,\r\n                        angle: Math.atan2(weapon.y - snake.y, weapon.x - snake.x),\r\n                        priority: this.calculateWeaponPriority(snake, weapon)\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Scan for ammo\r\n        this.ammo.forEach(ammoItem => {\r\n            if (!ammoItem.collected) {\r\n                const dist = Math.hypot(ammoItem.x - snake.x, ammoItem.y - snake.y);\r\n                if (dist < detectionRange) {\r\n                    situation.nearbyAmmo.push({\r\n                        ammo: ammoItem,\r\n                        distance: dist,\r\n                        angle: Math.atan2(ammoItem.y - snake.y, ammoItem.x - snake.x),\r\n                        needed: this.isAmmoNeeded(snake, ammoItem.type)\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Scan for food and orbs\r\n        this.food.forEach(food => {\r\n            const dist = Math.hypot(food.x - snake.x, food.y - snake.y);\r\n            if (dist < 200) {\r\n                situation.nearbyFood.push({\r\n                    food: food,\r\n                    distance: dist,\r\n                    angle: Math.atan2(food.y - snake.y, food.x - snake.x)\r\n                });\r\n            }\r\n        });\r\n\r\n        this.glowOrbs.forEach(orb => {\r\n            const dist = Math.hypot(orb.x - snake.x, orb.y - snake.y);\r\n            if (dist < detectionRange) {\r\n                situation.nearbyOrbs.push({\r\n                    orb: orb,\r\n                    distance: dist,\r\n                    angle: Math.atan2(orb.y - snake.y, orb.x - snake.x),\r\n                    priority: 10 // High priority for boost refill\r\n                });\r\n                situation.opportunityLevel += 5;\r\n            }\r\n        });\r\n\r\n        // Scan for coins (high priority for cash)\r\n        if (this.coins) {\r\n            this.coins.forEach(coin => {\r\n                if (coin.collected) return;\r\n                const dist = Math.hypot(coin.x - snake.x, coin.y - snake.y);\r\n                if (dist < detectionRange) {\r\n                    situation.nearbyCoins.push({\r\n                        coin: coin,\r\n                        distance: dist,\r\n                        angle: Math.atan2(coin.y - snake.y, coin.x - snake.x),\r\n                        priority: 15, // Very high priority for cash\r\n                        value: coin.value\r\n                    });\r\n                    situation.opportunityLevel += 8; // High opportunity value\r\n                }\r\n            });\r\n        }\r\n\r\n        // Scan for incoming projectiles\r\n        if (this.projectiles) {\r\n            this.projectiles.forEach(projectile => {\r\n                if (projectile.owner !== snake) {\r\n                    const dist = Math.hypot(projectile.x - snake.x, projectile.y - snake.y);\r\n                    const projectileAngle = Math.atan2(projectile.vy, projectile.vx);\r\n                    const toSnakeAngle = Math.atan2(snake.y - projectile.y, snake.x - projectile.x);\r\n                    const angleDiff = Math.abs(projectileAngle - toSnakeAngle);\r\n\r\n                    if (dist < 150 && angleDiff < 0.5) {\r\n                        situation.incomingProjectiles.push({\r\n                            projectile: projectile,\r\n                            distance: dist,\r\n                            timeToImpact: dist / Math.hypot(projectile.vx, projectile.vy),\r\n                            dangerLevel: projectile.damage / Math.max(dist, 1)\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        return situation;\r\n    }\r\n\r\n    updateGlowOrbs() {\r\n        this.glowOrbs.forEach(orb => {\r\n            orb.x += orb.vx;\r\n            orb.y += orb.vy;\r\n\r\n            // Bounce off world boundaries\r\n            if (orb.x < 0 || orb.x > this.worldWidth) orb.vx *= -1;\r\n            if (orb.y < 0 || orb.y > this.worldHeight) orb.vy *= -1;\r\n\r\n            orb.x = Math.max(0, Math.min(this.worldWidth, orb.x));\r\n            orb.y = Math.max(0, Math.min(this.worldHeight, orb.y));\r\n\r\n            orb.glow = (orb.glow + 0.1) % (Math.PI * 2);\r\n        });\r\n    }\r\n\r\n    convertSnakeToFood(snake) {\r\n        // Convert each segment of the dead snake into food\r\n        snake.segments.forEach((segment, index) => {\r\n            // Skip the head (index 0) to avoid too much food\r\n            if (index > 0) {\r\n                this.food.push({\r\n                    x: segment.x + (Math.random() - 0.5) * 20, // Add some spread\r\n                    y: segment.y + (Math.random() - 0.5) * 20,\r\n                    color: snake.isPlayer ? '#FFD700' : '#FF6B6B', // Gold for player, red for AI\r\n                    size: 8 + Math.random() * 4,\r\n                    value: 2 // Higher value than normal food\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    convertSnakeToCoins(snake) {\r\n        // Get the snake's actual cash balance at the moment of death\r\n        const totalCashValue = snake.isPlayer ?\r\n            this.cashBalance :\r\n            (snake.collectedCash || 0);\r\n\r\n        // Reduce snake's cash balance to zero (they lost everything)\r\n        if (snake.isPlayer) {\r\n            this.cashBalance = 0; // Player loses all cash on death\r\n            // In warfare mode, score equals cash; in classic mode, keep them separate\r\n            if (this.gameMode === 'warfare') {\r\n                this.score = this.cashBalance;\r\n            }\r\n        } else {\r\n            snake.collectedCash = 0; // AI loses all cash on death\r\n        }\r\n\r\n        // Calculate total number of coins to create\r\n        const totalCoins = snake.segments.length * 4; // 4 coins per segment for good distribution\r\n        const valuePerCoin = Math.max(1, Math.floor(totalCashValue / totalCoins)); // Minimum $1 per coin\r\n\r\n        snake.segments.forEach((segment) => {\r\n            // Create multiple coins per segment for better collection\r\n            const coinsPerSegment = 4; // Consistent number of coins per segment\r\n            for (let i = 0; i < coinsPerSegment; i++) {\r\n                this.coins.push({\r\n                    x: segment.x + (Math.random() - 0.5) * 40,\r\n                    y: segment.y + (Math.random() - 0.5) * 40,\r\n                    value: valuePerCoin,\r\n                    size: 8 + Math.random() * 4,\r\n                    color: '#FFD700', // Gold color for coins\r\n                    collected: false,\r\n                    bobPhase: Math.random() * Math.PI * 2,\r\n                    sparklePhase: Math.random() * Math.PI * 2,\r\n                    creationTime: Date.now()\r\n                });\r\n            }\r\n        });\r\n\r\n        console.log(`Snake died with $${totalCashValue} cash, created ${totalCoins} coins worth $${valuePerCoin} each (total: $${totalCoins * valuePerCoin})`);\r\n    }\r\n\r\n    breakOffSegments(snake, segmentIndex, attacker) {\r\n        // Calculate cash value of broken segments\r\n        const brokenSegments = snake.segments.splice(segmentIndex);\r\n        const segmentValue = this.calculateSegmentValue(snake);\r\n\r\n        // Calculate total value lost\r\n        const totalValueLost = segmentValue * brokenSegments.length;\r\n\r\n        // Reduce snake's cash balance based on lost segments\r\n        if (snake.isPlayer) {\r\n            this.cashBalance = Math.max(0, this.cashBalance - totalValueLost);\r\n            this.score = this.cashBalance; // Keep score in sync\r\n        } else {\r\n            snake.collectedCash = Math.max(0, (snake.collectedCash || 0) - totalValueLost);\r\n        }\r\n\r\n        // Create coins from broken segments\r\n        brokenSegments.forEach((segment, index) => {\r\n            // Create multiple coins per segment for better collection\r\n            for (let i = 0; i < 3; i++) {\r\n                this.coins.push({\r\n                    x: segment.x + (Math.random() - 0.5) * 30,\r\n                    y: segment.y + (Math.random() - 0.5) * 30,\r\n                    value: Math.floor(segmentValue / 3), // Divide value among coins\r\n                    size: 8 + Math.random() * 4,\r\n                    color: '#FFD700', // Gold color for coins\r\n                    collected: false,\r\n                    bobPhase: Math.random() * Math.PI * 2,\r\n                    sparklePhase: Math.random() * Math.PI * 2,\r\n                    creationTime: Date.now()\r\n                });\r\n            }\r\n        });\r\n\r\n        // Update snake's cash value\r\n        this.updateSnakeCashValue(snake);\r\n    }\r\n\r\n    calculateSegmentValue(snake) {\r\n        // Base value per segment based on wager\r\n        const baseValue = Math.max(snake.wager || 10, 10); // Minimum $10 per segment\r\n        return Math.floor(baseValue / 10); // $1 per segment for $10 wager, etc.\r\n    }\r\n\r\n    updateSnakeCashValue(snake) {\r\n        // Recalculate total cash value based on remaining segments\r\n        const segmentValue = this.calculateSegmentValue(snake);\r\n        snake.cashValue = snake.segments.length * segmentValue;\r\n    }\r\n\r\n    updateCoins() {\r\n        // Remove old coins (after 30 seconds)\r\n        const now = Date.now();\r\n        this.coins = this.coins.filter(coin => !coin.collected && (now - coin.creationTime) < 30000);\r\n\r\n        // Check coin collisions with all snakes\r\n        const allSnakes = [this.player, ...this.aiSnakes].filter(s => s.alive);\r\n\r\n        this.coins.forEach(coin => {\r\n            if (coin.collected) return;\r\n\r\n            allSnakes.forEach(snake => {\r\n                const dx = snake.segments[0].x - coin.x;\r\n                const dy = snake.segments[0].y - coin.y;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                if (distance < snake.size + coin.size) {\r\n                    coin.collected = true;\r\n\r\n                    // Add cash to snake\r\n                    if (snake.isPlayer) {\r\n                        this.cashBalance += coin.value;\r\n                        // In warfare mode, score equals cash; in classic mode, keep them separate\r\n                        if (this.gameMode === 'warfare') {\r\n                            this.score = this.cashBalance;\r\n                        }\r\n                    } else {\r\n                        // AI snakes collect cash too (for future features)\r\n                        snake.collectedCash = (snake.collectedCash || 0) + coin.value;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // AI Helper Methods\r\n    calculateThreatScore(snake, enemy, distance) {\r\n        let score = 0;\r\n\r\n        // Base threat from size difference\r\n        const sizeDiff = enemy.segments.length - snake.segments.length;\r\n        score += sizeDiff * 0.5;\r\n\r\n        // Weapon threat\r\n        if (enemy.currentWeapon && enemy.currentWeapon.type !== 'sidearm') {\r\n            score += enemy.currentWeapon.tier * 2;\r\n        }\r\n\r\n        // Distance factor (closer = more threatening)\r\n        score += (300 - distance) / 100;\r\n\r\n        // Player is always more threatening\r\n        if (enemy.isPlayer) {\r\n            score += 3;\r\n        }\r\n\r\n        return Math.max(0, score);\r\n    }\r\n\r\n    calculateWeaponPriority(snake, weapon) {\r\n        let priority = weapon.tier;\r\n\r\n        // Prefer weapons that match AI personality\r\n        if (snake.weaponPreference === weapon.type || snake.weaponPreference === 'balanced') {\r\n            priority += 2;\r\n        }\r\n\r\n        // Higher priority if current weapon is weak\r\n        if (!snake.currentWeapon || snake.currentWeapon.type === 'sidearm') {\r\n            priority += 3;\r\n        }\r\n\r\n        return priority;\r\n    }\r\n\r\n    isAmmoNeeded(snake, ammoType) {\r\n        if (!snake.ammoInventory) return false;\r\n\r\n        // Check if any weapon uses this ammo type\r\n        const weapons = [snake.weaponInventory?.primaryWeapon, snake.weaponInventory?.secondaryWeapon];\r\n        return weapons.some(weapon => weapon && weapon.ammoTypes.includes(ammoType) && weapon.currentAmmo < weapon.maxAmmo);\r\n    }\r\n\r\n    updateAICombatState(snake, situation) {\r\n        const now = Date.now();\r\n        const timeSinceStateChange = now - snake.lastStateChange;\r\n\r\n        // State transition logic based on situation\r\n        switch (snake.combatState) {\r\n            case 'hunting':\r\n                if (situation.threatLevel > 5) {\r\n                    snake.combatState = 'engaging';\r\n                    snake.lastStateChange = now;\r\n                } else if (situation.nearbyWeapons.length > 0 || situation.nearbyAmmo.length > 0) {\r\n                    snake.combatState = 'collecting';\r\n                    snake.lastStateChange = now;\r\n                }\r\n                break;\r\n\r\n            case 'engaging':\r\n                if (situation.threatLevel < 2 && timeSinceStateChange > 3000) {\r\n                    snake.combatState = 'hunting';\r\n                    snake.lastStateChange = now;\r\n                } else if (snake.boost < 30 || (snake.currentWeapon && snake.currentWeapon.currentAmmo < 3)) {\r\n                    snake.combatState = 'retreating';\r\n                    snake.lastStateChange = now;\r\n                }\r\n                break;\r\n\r\n            case 'retreating':\r\n                if (situation.threatLevel < 1 && timeSinceStateChange > 2000) {\r\n                    snake.combatState = 'collecting';\r\n                    snake.lastStateChange = now;\r\n                }\r\n                break;\r\n\r\n            case 'collecting':\r\n                if (situation.threatLevel > 3) {\r\n                    snake.combatState = 'engaging';\r\n                    snake.lastStateChange = now;\r\n                } else if (timeSinceStateChange > 5000) {\r\n                    snake.combatState = 'hunting';\r\n                    snake.lastStateChange = now;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n\r\n    executeAIBehavior(snake, situation) {\r\n        const action = {\r\n            targetX: snake.x,\r\n            targetY: snake.y,\r\n            shoot: false,\r\n            shootTarget: null,\r\n            boost: false,\r\n            switchWeapon: false\r\n        };\r\n\r\n        switch (snake.combatState) {\r\n            case 'hunting':\r\n                return this.executeHuntingBehavior(snake, situation, action);\r\n            case 'engaging':\r\n                return this.executeEngagingBehavior(snake, situation, action);\r\n            case 'retreating':\r\n                return this.executeRetreatingBehavior(snake, situation, action);\r\n            case 'collecting':\r\n                return this.executeCollectingBehavior(snake, situation, action);\r\n        }\r\n\r\n        return action;\r\n    }\r\n\r\n    executeHuntingBehavior(snake, situation, action) {\r\n        // Priority: Find enemies to engage or resources to collect\r\n\r\n        // Look for enemies to hunt\r\n        if (situation.nearbyEnemies.length > 0) {\r\n            const target = situation.nearbyEnemies\r\n                .filter(e => e.distance < 300) // Reasonable hunting range\r\n                .sort((a, b) => a.threatScore - b.threatScore)[0]; // Target weakest enemy\r\n\r\n            if (target) {\r\n                action.targetX = target.snake.x;\r\n                action.targetY = target.snake.y;\r\n                action.boost = target.distance > 100 && snake.boost > 50;\r\n\r\n                // Shoot if in range and have weapon (including sidearm) and not invincible\r\n                if (target.distance < 250 && snake.currentWeapon && !snake.isInvincible()) {\r\n                    action.shoot = true;\r\n                    action.shootTarget = { x: target.snake.x, y: target.snake.y };\r\n                }\r\n            }\r\n        }\r\n        // Look for coins (valuable cash)\r\n        else if (situation.nearbyCoins.length > 0) {\r\n            const coin = situation.nearbyCoins.sort((a, b) => {\r\n                const ratioA = a.value / Math.max(a.distance, 1);\r\n                const ratioB = b.value / Math.max(b.distance, 1);\r\n                return ratioB - ratioA;\r\n            })[0];\r\n            action.targetX = coin.coin.x;\r\n            action.targetY = coin.coin.y;\r\n            action.boost = coin.distance > 60 && snake.boost > 30;\r\n        }\r\n        // Look for valuable resources\r\n        else if (situation.nearbyOrbs.length > 0) {\r\n            const orb = situation.nearbyOrbs.sort((a, b) => a.distance - b.distance)[0];\r\n            action.targetX = orb.orb.x;\r\n            action.targetY = orb.orb.y;\r\n            action.boost = orb.distance > 80 && snake.boost > 30;\r\n        }\r\n        // Look for weapons if current weapon is weak\r\n        else if (situation.nearbyWeapons.length > 0 && (!snake.currentWeapon || snake.currentWeapon.type === 'sidearm')) {\r\n            const weapon = situation.nearbyWeapons.sort((a, b) => b.priority - a.priority)[0];\r\n            action.targetX = weapon.weapon.x;\r\n            action.targetY = weapon.weapon.y;\r\n            action.boost = weapon.distance > 100;\r\n        }\r\n        // Patrol behavior\r\n        else {\r\n            const dx = snake.patrolTarget.x - snake.x;\r\n            const dy = snake.patrolTarget.y - snake.y;\r\n            if (Math.hypot(dx, dy) < 50) {\r\n                // Pick new patrol target\r\n                snake.patrolTarget = {\r\n                    x: Math.random() * this.worldWidth,\r\n                    y: Math.random() * this.worldHeight\r\n                };\r\n            }\r\n            action.targetX = snake.patrolTarget.x;\r\n            action.targetY = snake.patrolTarget.y;\r\n        }\r\n\r\n        return action;\r\n    }\r\n\r\n    executeEngagingBehavior(snake, situation, action) {\r\n        // Priority: Combat with nearby enemies\r\n\r\n        if (situation.nearbyEnemies.length > 0) {\r\n            // Find best target based on threat and opportunity\r\n            const target = situation.nearbyEnemies.sort((a, b) => {\r\n                const scoreA = a.threatScore + (a.hasWeapon ? 2 : 0) - a.distance / 50;\r\n                const scoreB = b.threatScore + (b.hasWeapon ? 2 : 0) - b.distance / 50;\r\n                return scoreB - scoreA;\r\n            })[0];\r\n\r\n            // Predict enemy movement for better accuracy\r\n            const predictedX = target.snake.x + Math.cos(target.snake.angle) * target.snake.speed * 10;\r\n            const predictedY = target.snake.y + Math.sin(target.snake.angle) * target.snake.speed * 10;\r\n\r\n            // Combat positioning\r\n            if (target.distance < 80) {\r\n                // Too close - back away while shooting\r\n                action.targetX = snake.x - (target.snake.x - snake.x);\r\n                action.targetY = snake.y - (target.snake.y - snake.y);\r\n                action.boost = true;\r\n            } else if (target.distance > 180) {\r\n                // Too far - close distance\r\n                action.targetX = target.snake.x;\r\n                action.targetY = target.snake.y;\r\n                action.boost = snake.boost > 40;\r\n            } else {\r\n                // Good range - strafe and shoot\r\n                const strafeAngle = target.angle + Math.PI / 2;\r\n                action.targetX = snake.x + Math.cos(strafeAngle) * 50;\r\n                action.targetY = snake.y + Math.sin(strafeAngle) * 50;\r\n            }\r\n\r\n            // Shooting logic - increased range and more aggressive (only if not invincible)\r\n            if (snake.canShoot() && target.distance < 300 && !snake.isInvincible()) {\r\n                action.shoot = true;\r\n                action.shootTarget = { x: predictedX, y: predictedY };\r\n            }\r\n\r\n            // Weapon switching for optimal range\r\n            action.switchWeapon = this.shouldSwitchWeapon(snake, target.distance);\r\n        }\r\n\r\n        return action;\r\n    }\r\n\r\n    executeRetreatingBehavior(snake, situation, action) {\r\n        // Priority: Escape from threats and find safety\r\n\r\n        if (situation.nearbyEnemies.length > 0) {\r\n            // Calculate escape vector away from all threats\r\n            let escapeX = 0;\r\n            let escapeY = 0;\r\n\r\n            situation.nearbyEnemies.forEach(threat => {\r\n                const weight = 1 / Math.max(threat.distance, 1);\r\n                escapeX -= (threat.snake.x - snake.x) * weight;\r\n                escapeY -= (threat.snake.y - snake.y) * weight;\r\n            });\r\n\r\n            action.targetX = snake.x + escapeX;\r\n            action.targetY = snake.y + escapeY;\r\n            action.boost = true; // Always boost when retreating\r\n        }\r\n\r\n        // Look for glow orbs for boost refill while retreating\r\n        if (situation.nearbyOrbs.length > 0 && snake.boost < 50) {\r\n            const orb = situation.nearbyOrbs.sort((a, b) => a.distance - b.distance)[0];\r\n            action.targetX = orb.orb.x;\r\n            action.targetY = orb.orb.y;\r\n        }\r\n\r\n        return action;\r\n    }\r\n\r\n    executeCollectingBehavior(snake, situation, action) {\r\n        // Priority: Collect coins, weapons, ammo, and resources\r\n\r\n        // Prioritize coins for cash (highest priority)\r\n        if (situation.nearbyCoins.length > 0) {\r\n            const coin = situation.nearbyCoins.sort((a, b) => {\r\n                // Sort by value/distance ratio for efficiency\r\n                const ratioA = a.value / Math.max(a.distance, 1);\r\n                const ratioB = b.value / Math.max(b.distance, 1);\r\n                return ratioB - ratioA;\r\n            })[0];\r\n            action.targetX = coin.coin.x;\r\n            action.targetY = coin.coin.y;\r\n            action.boost = coin.distance > 60; // Boost to get coins quickly\r\n        }\r\n        // Prioritize glow orbs for boost\r\n        else if (situation.nearbyOrbs.length > 0) {\r\n            const orb = situation.nearbyOrbs.sort((a, b) => a.distance - b.distance)[0];\r\n            action.targetX = orb.orb.x;\r\n            action.targetY = orb.orb.y;\r\n            action.boost = orb.distance > 80;\r\n        }\r\n        // Collect weapons\r\n        else if (situation.nearbyWeapons.length > 0) {\r\n            const weapon = situation.nearbyWeapons.sort((a, b) => b.priority - a.priority)[0];\r\n            action.targetX = weapon.weapon.x;\r\n            action.targetY = weapon.weapon.y;\r\n            action.boost = weapon.distance > 100;\r\n        }\r\n        // Collect needed ammo\r\n        else if (situation.nearbyAmmo.length > 0) {\r\n            const ammo = situation.nearbyAmmo.filter(a => a.needed).sort((a, b) => a.distance - b.distance)[0];\r\n            if (ammo) {\r\n                action.targetX = ammo.ammo.x;\r\n                action.targetY = ammo.ammo.y;\r\n                action.boost = ammo.distance > 80;\r\n            }\r\n        }\r\n        // Collect food for growth\r\n        else if (situation.nearbyFood.length > 0) {\r\n            const food = situation.nearbyFood.sort((a, b) => a.distance - b.distance)[0];\r\n            action.targetX = food.food.x;\r\n            action.targetY = food.food.y;\r\n        }\r\n\r\n        return action;\r\n    }\r\n\r\n    shouldSwitchWeapon(snake, targetDistance) {\r\n        if (!snake.weaponInventory) return false;\r\n\r\n        const current = snake.currentWeapon;\r\n        if (!current) return true;\r\n\r\n        // Switch to long-range weapon for distant targets\r\n        if (targetDistance > 150) {\r\n            const longRange = snake.weaponInventory.primaryWeapon;\r\n            if (longRange && longRange.type === 'rail_gun' && longRange.currentAmmo > 0) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Switch to close-range weapon for close targets\r\n        if (targetDistance < 100) {\r\n            const closeRange = snake.weaponInventory.secondaryWeapon;\r\n            if (closeRange && (closeRange.type === 'plasma_smg' || closeRange.type === 'rocket_launcher') && closeRange.currentAmmo > 0) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    handleAIWeaponSwitch(snake, situation) {\r\n        if (!snake.weaponInventory) return;\r\n\r\n        // Simple weapon switching logic\r\n        const weapons = ['primaryWeapon', 'secondaryWeapon', 'sidearm'];\r\n        const currentIndex = weapons.indexOf(snake.weaponInventory.currentSlot);\r\n        const nextIndex = (currentIndex + 1) % weapons.length;\r\n        const nextSlot = weapons[nextIndex];\r\n\r\n        if (snake.weaponInventory[nextSlot] && snake.weaponInventory[nextSlot].currentAmmo > 0) {\r\n            snake.switchToWeapon(nextSlot);\r\n        }\r\n    }\r\n\r\n    checkCollisions() {\r\n        const allSnakes = [this.player, ...this.aiSnakes].filter(s => s.alive);\r\n\r\n        // Check food collisions with vacuum effect\r\n        allSnakes.forEach(snake => {\r\n            const vacuumRadius = snake.size * 3.5; // Larger vacuum radius\r\n\r\n            // Regular food\r\n            for (let i = this.food.length - 1; i >= 0; i--) {\r\n                const food = this.food[i];\r\n                const dist = Math.hypot(food.x - snake.x, food.y - snake.y);\r\n\r\n                // Vacuum effect - pull food toward snake\r\n                if (dist < vacuumRadius && dist > snake.size + food.size) {\r\n                    // Stronger pull that increases as food gets closer\r\n                    const distanceRatio = 1 - (dist / vacuumRadius);\r\n                    const pullStrength = 1.2 + distanceRatio * 2.0; // Much stronger pull\r\n                    const angle = Math.atan2(snake.y - food.y, snake.x - food.x);\r\n                    food.x += Math.cos(angle) * pullStrength;\r\n                    food.y += Math.sin(angle) * pullStrength;\r\n                }\r\n\r\n                // Collect food on contact\r\n                if (dist < snake.size + food.size) {\r\n                    this.food.splice(i, 1);\r\n\r\n                    if (snake === this.player) {\r\n                        // Food gives 5% mass (growth) and 1% speed boost in both modes\r\n                        // 5% mass = 5% of what coins give for growth\r\n                        const coinMassValue = 10; // What coins give for mass/length\r\n                        const foodMassValue = coinMassValue * 0.05; // 5% of coin mass value\r\n\r\n                        // Add mass/growth (no cap on snake growth)\r\n                        this.player.growthQueue += foodMassValue;\r\n\r\n                        // Add 1% speed boost (remove cap when collecting food)\r\n                        this.player.addSpeedBoost(1);\r\n\r\n                        // Food adds to boost percentage and removes cap\r\n                        this.player.boostCapRemoved = true; // Remove boost cap when collecting food\r\n                        this.player.boost += 5; // Add 5% boost (no cap when collecting food)\r\n\r\n                        // Player ate food\r\n\r\n                        if (this.gameMode === 'warfare') {\r\n                            this.score = this.cashBalance; // In warfare mode, score equals cash\r\n                        }\r\n                        this.updateGameState();\r\n                    } else {\r\n                        // AI snakes also get benefits from food (same as player)\r\n                        // Food gives 5% mass (growth) and 1% speed boost in both modes\r\n                        const coinMassValue = 10; // What coins give for mass/length\r\n                        const foodMassValue = coinMassValue * 0.05; // 5% of coin mass value\r\n\r\n                        // Add mass/growth (no cap on snake growth)\r\n                        snake.growthQueue += foodMassValue;\r\n\r\n                        // Add 1% speed boost (remove cap when collecting food)\r\n                        snake.addSpeedBoost(1);\r\n\r\n                        // Food adds to boost percentage and removes cap\r\n                        snake.boostCapRemoved = true; // Remove boost cap when collecting food\r\n                        snake.boost += 5; // Add 5% boost (no cap when collecting food)\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Glow orbs\r\n            for (let i = this.glowOrbs.length - 1; i >= 0; i--) {\r\n                const orb = this.glowOrbs[i];\r\n                const dist = Math.hypot(orb.x - snake.x, orb.y - snake.y);\r\n\r\n                // Vacuum effect for glow orbs\r\n                if (dist < vacuumRadius && dist > snake.size + orb.size) {\r\n                    const distanceRatio = 1 - (dist / vacuumRadius);\r\n                    const pullStrength = 0.8 + distanceRatio * 1.5; // Slightly weaker than food\r\n                    const angle = Math.atan2(snake.y - orb.y, snake.x - orb.x);\r\n                    orb.x += Math.cos(angle) * pullStrength;\r\n                    orb.y += Math.sin(angle) * pullStrength;\r\n                }\r\n\r\n                if (dist < snake.size + orb.size) {\r\n                    this.glowOrbs.splice(i, 1);\r\n\r\n                    // Golden orbs add 100% boost in both modes\r\n                    snake.boost += 100; // ADD 100% boost, don't set to 100%\r\n                    console.log(`Golden orb collected! Boost increased by 100%, now at ${snake.boost}%`);\r\n\r\n                    if (this.gameMode === 'classic') {\r\n                        // Classic mode - orbs also give growth\r\n                        for (let j = 0; j < orb.value; j++) {\r\n                            snake.grow();\r\n                        }\r\n                        if (snake === this.player) {\r\n                            this.score += orb.value * 2;\r\n                        }\r\n                    }\r\n\r\n                    if (snake === this.player) {\r\n                        this.updateGameState();\r\n                    }\r\n\r\n                    // Spawn new glow orb\r\n                    const hue = Math.random() * 360;\r\n                    this.glowOrbs.push({\r\n                        x: Math.random() * this.worldWidth,\r\n                        y: Math.random() * this.worldHeight,\r\n                        vx: (Math.random() - 0.5) * 2,\r\n                        vy: (Math.random() - 0.5) * 2,\r\n                        hue: hue,\r\n                        size: 8 + Math.random() * 4,\r\n                        glow: 0,\r\n                        value: 5\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Check snake vs snake collisions\r\n        allSnakes.forEach(snake => {\r\n            allSnakes.forEach(otherSnake => {\r\n                if (snake === otherSnake || !snake.alive || !otherSnake.alive) return;\r\n\r\n                // Check if either snake is invincible\r\n                // Remote players don't have isInvincible method\r\n                const snakeInvincible = (typeof snake.isInvincible === 'function') ? snake.isInvincible() : (snake.isInvincible || false);\r\n                const otherSnakeInvincible = (typeof otherSnake.isInvincible === 'function') ? otherSnake.isInvincible() : (otherSnake.isInvincible || false);\r\n                if (snakeInvincible || otherSnakeInvincible) {\r\n                    return; // Skip collision for invincible snakes\r\n                }\r\n\r\n                // Check if snake head hits other snake's body\r\n                otherSnake.segments.forEach((segment, index) => {\r\n                    if (index === 0) return; // Skip head\r\n\r\n                    const dist = Math.hypot(segment.x - snake.x, segment.y - snake.y);\r\n                    if (dist < snake.size + otherSnake.size - 2) {\r\n                        // Check for battering ram collision damage (only if attacker is not invincible)\r\n                        const batteringRamDamage = snake.getBoostDamage();\r\n                        const isRamming = snake.boost < snake.maxBoost && batteringRamDamage > 0 && !snake.isInvincible(); // Snake is boosting and has battering ram and not invincible\r\n\r\n                        if (isRamming) {\r\n                            // Apply battering ram damage to the segment\r\n                            segment.health -= batteringRamDamage;\r\n\r\n                            if (segment.health <= 0) {\r\n                                // Break off segments from the collision point\r\n                                this.breakOffSegments(otherSnake, index, snake);\r\n                                return; // Don't kill the ramming snake\r\n                            } else {\r\n                                // Segment damaged but not destroyed, ramming snake bounces off\r\n                                // Apply some knockback to the ramming snake\r\n                                const knockbackAngle = Math.atan2(snake.y - segment.y, snake.x - segment.x);\r\n                                snake.x += Math.cos(knockbackAngle) * 20;\r\n                                snake.y += Math.sin(knockbackAngle) * 20;\r\n                                return; // Don't kill the ramming snake\r\n                            }\r\n                        }\r\n\r\n                        // Normal collision - snake dies (only if attacker is not invincible)\r\n                        if (!snake.isInvincible()) {\r\n                            snake.alive = false;\r\n\r\n                            // Convert dead snake to coins (gambling mechanics in both modes)\r\n                            this.convertSnakeToCoins(snake);\r\n\r\n                            // Check if player died for game over\r\n                            if (snake.isPlayer) {\r\n                                console.log('Player died from collision, calling gameOver()');\r\n                                this.gameOver();\r\n                                return; // Exit early to prevent further processing\r\n                            } else {\r\n                                // Respawn AI snake\r\n                                setTimeout(() => {\r\n                                    const x = Math.random() * this.worldWidth;\r\n                                    const y = Math.random() * this.worldHeight;\r\n                                    const colors = ['#ff0080', '#00ff41', '#00ffff', '#ff8000', '#8000ff', '#ffff00', '#ff4444', '#44ff44', '#4444ff'];\r\n                                    const color = colors[Math.floor(Math.random() * colors.length)];\r\n                                    const newSnake = new Snake(x, y, color, false);\r\n                                    newSnake.gameInstance = this; // Set game reference\r\n\r\n                                    // Set random wager for respawned AI snakes in both modes (gambling mechanics in both)\r\n                                    newSnake.wager = this.availableWagers[Math.floor(Math.random() * this.availableWagers.length)];\r\n                                    // Give AI starting cash equal to their wager\r\n                                    newSnake.collectedCash = newSnake.wager;\r\n                                    this.updateSnakeCashValue(newSnake);\r\n\r\n                                    // Activate spawn invincibility for respawned AI snake\r\n                                    // Remote players don't have activateSpawnInvincibility method\r\n                                    if (typeof newSnake.activateSpawnInvincibility === 'function') {\r\n                                        newSnake.activateSpawnInvincibility(newSnake.wager);\r\n                                    }\r\n\r\n                                    const index = this.aiSnakes.indexOf(snake);\r\n                                    if (index !== -1) {\r\n                                        this.aiSnakes[index] = newSnake;\r\n                                        console.log(`Respawned AI snake: ${newSnake.aiPersonality?.name || 'Classic'} at (${Math.round(x)}, ${Math.round(y)}) with wager $${newSnake.wager || 0}`);\r\n                                    }\r\n                                }, 3000);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        });\r\n\r\n        // Respawn food if needed - more food in warfare mode\r\n        const maxFood = this.gameMode === 'warfare' ? 800 : 400; // Double food in warfare mode\r\n        const spawnAmount = this.gameMode === 'warfare' ? 100 : 50; // Spawn more at once in warfare mode\r\n\r\n        if (this.food.length < maxFood) {\r\n            for (let i = 0; i < spawnAmount; i++) {\r\n                this.food.push({\r\n                    x: Math.random() * this.worldWidth,\r\n                    y: Math.random() * this.worldHeight,\r\n                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,\r\n                    size: 4 + Math.random() * 3\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    gameOver() {\r\n        console.log('💀💀💀 GAME OVER METHOD CALLED 💀💀💀');\r\n        this.gameRunning = false;\r\n\r\n        // Ensure player is marked as dead\r\n        if (this.player) {\r\n            this.player.alive = false;\r\n        }\r\n\r\n        // Create proper game over state\r\n        const gameOverState = {\r\n            score: this.gameMode === 'warfare' ? this.cashBalance : this.score,\r\n            cashBalance: this.cashBalance,\r\n            length: this.player ? this.player.segments.length : 0,\r\n            boost: this.player ? this.player.boost : 0,\r\n            weapon: this.currentWeapon ? this.currentWeapon.name : 'None',\r\n            cooldown: 'Ready',\r\n            isGameOver: true,\r\n            finalScore: this.gameMode === 'warfare' ? this.cashBalance : this.score,\r\n            finalLength: this.player ? this.player.segments.length : 0,\r\n            gameMode: this.gameMode,\r\n            cashedOut: this.cashedOut || false,\r\n            spectating: this.spectating || false\r\n        };\r\n\r\n        console.log('Game over state:', gameOverState);\r\n\r\n        // Call the game over callback if it exists\r\n        if (this.onGameOver) {\r\n            console.log('Calling onGameOver callback');\r\n            this.onGameOver(gameOverState);\r\n        } else {\r\n            console.log('No onGameOver callback found');\r\n        }\r\n\r\n        // Also update the regular game state\r\n        if (this.onStateUpdate) {\r\n            console.log('Calling onStateUpdate with game over state');\r\n            this.onStateUpdate(gameOverState);\r\n        } else {\r\n            console.log('No onStateUpdate callback found');\r\n        }\r\n    }\r\n\r\n\r\n\r\n    updateCamera() {\r\n        let targetX, targetY;\r\n\r\n        if (this.spectating) {\r\n            // Follow spectated snake\r\n            const aliveSnakes = this.aiSnakes.filter(snake => snake.alive);\r\n            if (aliveSnakes.length > 0) {\r\n                const spectatedSnake = aliveSnakes[this.spectateTarget % aliveSnakes.length];\r\n                targetX = spectatedSnake.x - this.canvas.width / 2;\r\n                targetY = spectatedSnake.y - this.canvas.height / 2;\r\n            } else {\r\n                // No snakes left to spectate, keep current camera position\r\n                return;\r\n            }\r\n        } else if (this.player && this.player.alive) {\r\n            // Follow the player\r\n            targetX = this.player.x - this.canvas.width / 2;\r\n            targetY = this.player.y - this.canvas.height / 2;\r\n        } else {\r\n            // Player is dead but not spectating, keep current camera position\r\n            return;\r\n        }\r\n\r\n        // Smooth camera movement\r\n        this.camera.x += (targetX - this.camera.x) * 0.1;\r\n        this.camera.y += (targetY - this.camera.y) * 0.1;\r\n\r\n        // Keep camera within world bounds\r\n        this.camera.x = Math.max(0, Math.min(this.worldWidth - this.canvas.width, this.camera.x));\r\n        this.camera.y = Math.max(0, Math.min(this.worldHeight - this.canvas.height, this.camera.y));\r\n    }\r\n\r\n    updateKing() {\r\n        // Find the snake with the highest balance\r\n        const allSnakes = [this.player, ...this.aiSnakes].filter(snake => snake.alive);\r\n\r\n        if (allSnakes.length === 0) return;\r\n\r\n        let newKing = allSnakes[0];\r\n        let highestBalance = this.player.isPlayer ? this.cashBalance : (allSnakes[0].collectedCash || 0);\r\n\r\n        allSnakes.forEach(snake => {\r\n            const balance = snake.isPlayer ? this.cashBalance : (snake.collectedCash || 0);\r\n            if (balance > highestBalance) {\r\n                highestBalance = balance;\r\n                newKing = snake;\r\n            }\r\n        });\r\n\r\n        // Only update if king changed or if there's no current king\r\n        if (this.currentKing !== newKing) {\r\n            this.currentKing = newKing;\r\n            console.log(`New king: ${newKing.isPlayer ? 'Player' : 'AI'} with balance $${highestBalance}`);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    render() {\r\n        // Debug logging\r\n        if (Math.random() < 0.01) { // Log occasionally to avoid spam\r\n            console.log('Rendering frame, canvas size:', this.canvas.width, 'x', this.canvas.height);\r\n        }\r\n\r\n        // Clear main canvas\r\n        this.ctx.fillStyle = '#0a0a0a';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        // Draw grid\r\n        this.drawGrid();\r\n\r\n        // Draw food\r\n        this.drawFood();\r\n\r\n        // Draw glow orbs\r\n        this.drawGlowOrbs();\r\n\r\n        // Draw snakes\r\n        this.drawSnakes();\r\n\r\n        // Draw warfare mode elements\r\n        if (this.gameMode === 'warfare') {\r\n            this.drawWeapons();\r\n            this.drawAmmo();\r\n            this.drawPowerups();\r\n            this.drawProjectiles();\r\n        }\r\n\r\n        // Draw coins in both modes (gambling mechanics in both)\r\n        this.drawCoins();\r\n\r\n        // Draw king indicator\r\n        this.drawKingIndicator();\r\n\r\n        // Draw debug info\r\n        this.drawDebugInfo();\r\n\r\n        // Draw minimap\r\n        this.drawMinimap();\r\n    }\r\n\r\n    drawWeapons() {\r\n        this.weapons.forEach(weapon => {\r\n            if (!weapon.collected) {\r\n                weapon.draw(this.ctx, this.camera.x, this.camera.y);\r\n            }\r\n        });\r\n    }\r\n\r\n    drawAmmo() {\r\n        this.ammo.forEach(ammoItem => {\r\n            if (!ammoItem.collected) {\r\n                ammoItem.draw(this.ctx, this.camera.x, this.camera.y);\r\n            }\r\n        });\r\n    }\r\n\r\n    drawPowerups() {\r\n        this.powerups.forEach(powerupItem => {\r\n            if (!powerupItem.collected) {\r\n                powerupItem.draw(this.ctx, this.camera.x, this.camera.y);\r\n            }\r\n        });\r\n    }\r\n\r\n    drawCoins() {\r\n        if (!this.coins) return;\r\n\r\n        const time = Date.now() * 0.001;\r\n\r\n        this.coins.forEach(coin => {\r\n            if (coin.collected) return;\r\n\r\n            const x = coin.x - this.camera.x;\r\n            const y = coin.y - this.camera.y;\r\n\r\n            // Skip if off-screen\r\n            if (x < -50 || x > this.canvas.width + 50 || y < -50 || y > this.canvas.height + 50) {\r\n                return;\r\n            }\r\n\r\n            // Bobbing animation\r\n            const bobOffset = Math.sin(time * 3 + coin.bobPhase) * 3;\r\n            const finalY = y + bobOffset;\r\n\r\n            // Sparkle animation\r\n            const sparkleIntensity = Math.sin(time * 4 + coin.sparklePhase) * 0.5 + 0.5;\r\n\r\n            // Draw coin glow\r\n            const glowSize = coin.size * (2 + sparkleIntensity * 0.5);\r\n            const glowGradient = this.ctx.createRadialGradient(x, finalY, 0, x, finalY, glowSize);\r\n            glowGradient.addColorStop(0, '#FFD700');\r\n            glowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.6)');\r\n            glowGradient.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = glowGradient;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, finalY, glowSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Draw main coin\r\n            const coinGradient = this.ctx.createRadialGradient(\r\n                x - coin.size * 0.3, finalY - coin.size * 0.3, 0,\r\n                x, finalY, coin.size\r\n            );\r\n            coinGradient.addColorStop(0, '#FFFF80');\r\n            coinGradient.addColorStop(0.7, '#FFD700');\r\n            coinGradient.addColorStop(1, '#B8860B');\r\n\r\n            this.ctx.fillStyle = coinGradient;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, finalY, coin.size, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Draw coin outline\r\n            this.ctx.strokeStyle = '#B8860B';\r\n            this.ctx.lineWidth = 2;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, finalY, coin.size, 0, Math.PI * 2);\r\n            this.ctx.stroke();\r\n\r\n            // Draw dollar sign\r\n            this.ctx.fillStyle = '#8B4513';\r\n            this.ctx.font = `${coin.size * 1.2}px bold monospace`;\r\n            this.ctx.textAlign = 'center';\r\n            this.ctx.textBaseline = 'middle';\r\n            this.ctx.fillText('$', x, finalY);\r\n\r\n            // Draw sparkles around coin\r\n            for (let i = 0; i < 4; i++) {\r\n                const sparkleAngle = (time * 2 + i * Math.PI / 2) % (Math.PI * 2);\r\n                const sparkleDistance = coin.size * 1.8;\r\n                const sparkleX = x + Math.cos(sparkleAngle) * sparkleDistance;\r\n                const sparkleY = finalY + Math.sin(sparkleAngle) * sparkleDistance;\r\n\r\n                this.ctx.fillStyle = `rgba(255, 255, 255, ${sparkleIntensity})`;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(sparkleX, sparkleY, 1.5, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n            }\r\n        });\r\n    }\r\n\r\n    drawProjectiles() {\r\n        if (!this.projectiles) return;\r\n\r\n        this.projectiles.forEach(projectile => {\r\n            // Validate projectile coordinates\r\n            if (!isFinite(projectile.x) || !isFinite(projectile.y)) {\r\n                console.warn('Invalid projectile position:', projectile.x, projectile.y);\r\n                return;\r\n            }\r\n\r\n            const screenX = projectile.x - this.camera.x;\r\n            const screenY = projectile.y - this.camera.y;\r\n\r\n            // Validate screen coordinates\r\n            if (!isFinite(screenX) || !isFinite(screenY)) {\r\n                console.warn('Invalid screen coordinates:', screenX, screenY);\r\n                return;\r\n            }\r\n\r\n            // Don't draw if off screen\r\n            if (screenX < -100 || screenX > this.canvas.width + 100 ||\r\n                screenY < -100 || screenY > this.canvas.height + 100) {\r\n                return;\r\n            }\r\n\r\n            const time = Date.now() * 0.001;\r\n            const age = (Date.now() - projectile.creationTime) * 0.001;\r\n\r\n            // Draw projectile based on type with enhanced animations\r\n            switch (projectile.type) {\r\n                case 'sidearm':\r\n                    this.drawDefaultProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n                case 'laser_pistol':\r\n                case 'laser_rifle':\r\n                    this.drawLaserProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n                case 'plasma_smg':\r\n                case 'plasma_cannon':\r\n                    this.drawPlasmaProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n                case 'rocket_launcher':\r\n                    this.drawMissileProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n                case 'rail_gun':\r\n                    this.drawRailGunProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n                default:\r\n                    this.drawDefaultProjectile(projectile, screenX, screenY, time, age);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    drawLaserProjectile(projectile, x, y, time, age) {\r\n        this.ctx.save();\r\n\r\n        // Draw laser beam with glow effects\r\n        const beamLength = 30;\r\n        const angle = projectile.angle;\r\n\r\n        // Multiple glow layers for intense effect\r\n        for (let i = 0; i < 3; i++) {\r\n            const glowSize = (3 - i) * 4;\r\n            const alpha = 0.3 - i * 0.1;\r\n\r\n            this.ctx.strokeStyle = `rgba(255, 68, 68, ${alpha})`;\r\n            this.ctx.lineWidth = glowSize;\r\n            this.ctx.lineCap = 'round';\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(\r\n                x - Math.cos(angle) * beamLength,\r\n                y - Math.sin(angle) * beamLength\r\n            );\r\n            this.ctx.lineTo(\r\n                x + Math.cos(angle) * beamLength,\r\n                y + Math.sin(angle) * beamLength\r\n            );\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        // Core beam\r\n        this.ctx.strokeStyle = '#FFFFFF';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(\r\n            x - Math.cos(angle) * beamLength,\r\n            y - Math.sin(angle) * beamLength\r\n        );\r\n        this.ctx.lineTo(\r\n            x + Math.cos(angle) * beamLength,\r\n            y + Math.sin(angle) * beamLength\r\n        );\r\n        this.ctx.stroke();\r\n\r\n        // Sparks and particles\r\n        for (let i = 0; i < 6; i++) {\r\n            const sparkAngle = angle + (Math.random() - 0.5) * 0.5;\r\n            const sparkDistance = 15 + Math.random() * 10;\r\n            const sparkX = x + Math.cos(sparkAngle) * sparkDistance;\r\n            const sparkY = y + Math.sin(sparkAngle) * sparkDistance;\r\n\r\n            this.ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.8})`;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(sparkX, sparkY, 1 + Math.random() * 2, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawPlasmaProjectile(projectile, x, y, time, age) {\r\n        this.ctx.save();\r\n\r\n        const pulseSize = 12 + Math.sin(time * 8 + projectile.animationOffset) * 4;\r\n\r\n        // Draw trail\r\n        this.drawProjectileTrail(projectile, '#44FF44', 0.6);\r\n\r\n        // Outer energy field\r\n        const outerGradient = this.ctx.createRadialGradient(x, y, 0, x, y, pulseSize * 2);\r\n        outerGradient.addColorStop(0, 'rgba(68, 255, 68, 0.4)');\r\n        outerGradient.addColorStop(0.5, 'rgba(68, 255, 68, 0.2)');\r\n        outerGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = outerGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, pulseSize * 2, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Main plasma ball\r\n        const plasmaGradient = this.ctx.createRadialGradient(x, y, 0, x, y, pulseSize);\r\n        plasmaGradient.addColorStop(0, '#FFFFFF');\r\n        plasmaGradient.addColorStop(0.3, '#44FF44');\r\n        plasmaGradient.addColorStop(0.7, '#228822');\r\n        plasmaGradient.addColorStop(1, 'rgba(34, 136, 34, 0.5)');\r\n\r\n        this.ctx.fillStyle = plasmaGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, pulseSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Electric arcs\r\n        this.ctx.strokeStyle = '#FFFFFF';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.lineCap = 'round';\r\n\r\n        for (let i = 0; i < 6; i++) {\r\n            const arcAngle = (time * 4 + projectile.animationOffset + i * Math.PI / 3) % (Math.PI * 2);\r\n            const arcLength = pulseSize * 1.5;\r\n            const startX = x + Math.cos(arcAngle) * pulseSize * 0.7;\r\n            const startY = y + Math.sin(arcAngle) * pulseSize * 0.7;\r\n            const endX = x + Math.cos(arcAngle) * arcLength;\r\n            const endY = y + Math.sin(arcAngle) * arcLength;\r\n\r\n            // Zigzag effect for electric arc\r\n            const midX = (startX + endX) / 2 + (Math.random() - 0.5) * 8;\r\n            const midY = (startY + endY) / 2 + (Math.random() - 0.5) * 8;\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(startX, startY);\r\n            this.ctx.lineTo(midX, midY);\r\n            this.ctx.lineTo(endX, endY);\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawMissileProjectile(projectile, x, y, time, age) {\r\n        this.ctx.save();\r\n\r\n        // Draw exhaust trail\r\n        this.drawProjectileTrail(projectile, '#FF8844', 0.8);\r\n\r\n        // Rotate missile to face direction of travel\r\n        this.ctx.translate(x, y);\r\n        this.ctx.rotate(projectile.angle);\r\n\r\n        // Missile body\r\n        const missileGradient = this.ctx.createLinearGradient(-8, -4, -8, 4);\r\n        missileGradient.addColorStop(0, '#FFAA88');\r\n        missileGradient.addColorStop(0.5, '#FF8844');\r\n        missileGradient.addColorStop(1, '#CC6622');\r\n\r\n        this.ctx.fillStyle = missileGradient;\r\n        this.ctx.fillRect(-8, -3, 16, 6);\r\n\r\n        // Missile tip\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(8, 0);\r\n        this.ctx.lineTo(12, -2);\r\n        this.ctx.lineTo(12, 2);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        // Fins\r\n        this.ctx.fillStyle = '#FF6622';\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(-8, -3);\r\n        this.ctx.lineTo(-12, -5);\r\n        this.ctx.lineTo(-10, -2);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(-8, 3);\r\n        this.ctx.lineTo(-12, 5);\r\n        this.ctx.lineTo(-10, 2);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        // Exhaust flame\r\n        const exhaustPulse = Math.sin(time * 12 + projectile.animationOffset) * 0.3 + 0.7;\r\n        const flameGradient = this.ctx.createRadialGradient(-8, 0, 0, -15, 0, 8);\r\n        flameGradient.addColorStop(0, `rgba(255, 255, 255, ${exhaustPulse})`);\r\n        flameGradient.addColorStop(0.3, `rgba(255, 136, 68, ${exhaustPulse * 0.8})`);\r\n        flameGradient.addColorStop(0.7, `rgba(255, 68, 68, ${exhaustPulse * 0.6})`);\r\n        flameGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = flameGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.ellipse(-12, 0, 8 * exhaustPulse, 4 * exhaustPulse, 0, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawRailGunProjectile(projectile, x, y, time, age) {\r\n        this.ctx.save();\r\n\r\n        // Draw electromagnetic trail\r\n        this.drawProjectileTrail(projectile, '#4444FF', 0.9);\r\n\r\n        // Rail gun projectile - high-energy electromagnetic slug\r\n        const coreSize = 6;\r\n        const fieldSize = 16;\r\n\r\n        // Electromagnetic field effect\r\n        const fieldGradient = this.ctx.createRadialGradient(x, y, 0, x, y, fieldSize);\r\n        fieldGradient.addColorStop(0, 'rgba(68, 68, 255, 0.8)');\r\n        fieldGradient.addColorStop(0.5, 'rgba(68, 68, 255, 0.4)');\r\n        fieldGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = fieldGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, fieldSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Electromagnetic field lines\r\n        this.ctx.strokeStyle = '#8888FF';\r\n        this.ctx.lineWidth = 1;\r\n        for (let i = 0; i < 6; i++) {\r\n            const angle = (time * 10 + i * Math.PI / 3) % (Math.PI * 2);\r\n            const innerRadius = coreSize;\r\n            const outerRadius = fieldSize * 0.8;\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(\r\n                x + Math.cos(angle) * innerRadius,\r\n                y + Math.sin(angle) * innerRadius\r\n            );\r\n            this.ctx.lineTo(\r\n                x + Math.cos(angle) * outerRadius,\r\n                y + Math.sin(angle) * outerRadius\r\n            );\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        // Core projectile\r\n        const coreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, coreSize);\r\n        coreGradient.addColorStop(0, '#FFFFFF');\r\n        coreGradient.addColorStop(0.7, '#AAAAFF');\r\n        coreGradient.addColorStop(1, '#4444FF');\r\n\r\n        this.ctx.fillStyle = coreGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, coreSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Bright core\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, coreSize * 0.4, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawDefaultProjectile(projectile, x, y, time, age) {\r\n        // Check if this is a tracer round\r\n        if (projectile.isTracer) {\r\n            this.drawTracerRound(projectile, x, y, time, age);\r\n            return;\r\n        }\r\n\r\n        // Validate coordinates to prevent canvas errors\r\n        if (!isFinite(x) || !isFinite(y)) {\r\n            console.warn('Invalid projectile coordinates:', x, y);\r\n            return;\r\n        }\r\n\r\n        // Simple white projectile with glow\r\n        const glowGradient = this.ctx.createRadialGradient(x, y, 0, x, y, 8);\r\n        glowGradient.addColorStop(0, '#FFFFFF');\r\n        glowGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.5)');\r\n        glowGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = glowGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, 8, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, 4, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n    }\r\n\r\n    drawTracerRound(projectile, x, y, time, age) {\r\n        // Validate coordinates to prevent canvas errors\r\n        if (!isFinite(x) || !isFinite(y)) {\r\n            console.warn('Invalid tracer coordinates:', x, y);\r\n            return;\r\n        }\r\n\r\n        this.ctx.save();\r\n\r\n        // Calculate trail length based on velocity\r\n        const velocity = Math.hypot(projectile.vx, projectile.vy);\r\n        const trailLength = Math.min(velocity * 2, 40); // Max trail length of 40 pixels\r\n\r\n        // Calculate trail start position\r\n        const angle = Math.atan2(projectile.vy, projectile.vx);\r\n        const trailStartX = x - Math.cos(angle) * trailLength;\r\n        const trailStartY = y - Math.sin(angle) * trailLength;\r\n\r\n        // Draw bright yellow tracer trail\r\n        const gradient = this.ctx.createLinearGradient(trailStartX, trailStartY, x, y);\r\n        gradient.addColorStop(0, 'rgba(255, 255, 0, 0)'); // Transparent start\r\n        gradient.addColorStop(0.3, 'rgba(255, 255, 0, 0.3)'); // Fading yellow\r\n        gradient.addColorStop(0.7, 'rgba(255, 255, 0, 0.8)'); // Bright yellow\r\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 1)'); // White hot tip\r\n\r\n        this.ctx.strokeStyle = gradient;\r\n        this.ctx.lineWidth = 4;\r\n        this.ctx.lineCap = 'round';\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(trailStartX, trailStartY);\r\n        this.ctx.lineTo(x, y);\r\n        this.ctx.stroke();\r\n\r\n        // Draw bright projectile tip\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.shadowColor = '#FFFF00';\r\n        this.ctx.shadowBlur = 8;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, 2, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Add glow effect\r\n        this.ctx.shadowBlur = 15;\r\n        this.ctx.fillStyle = '#FFFF00';\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, 4, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawProjectileTrail(projectile, color, maxAlpha) {\r\n        if (!projectile.trail || projectile.trail.length < 2) return;\r\n\r\n        this.ctx.save();\r\n\r\n        for (let i = 0; i < projectile.trail.length - 1; i++) {\r\n            const current = projectile.trail[i];\r\n            const next = projectile.trail[i + 1];\r\n\r\n            const currentScreen = {\r\n                x: current.x - this.camera.x,\r\n                y: current.y - this.camera.y\r\n            };\r\n            const nextScreen = {\r\n                x: next.x - this.camera.x,\r\n                y: next.y - this.camera.y\r\n            };\r\n\r\n            const alpha = (i / projectile.trail.length) * maxAlpha;\r\n            const width = (i / projectile.trail.length) * 6 + 1;\r\n\r\n            this.ctx.strokeStyle = color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');\r\n            this.ctx.lineWidth = width;\r\n            this.ctx.lineCap = 'round';\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(currentScreen.x, currentScreen.y);\r\n            this.ctx.lineTo(nextScreen.x, nextScreen.y);\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawGrid() {\r\n        this.ctx.strokeStyle = '#1a1a1a';\r\n        this.ctx.lineWidth = 1;\r\n\r\n        const gridSize = 50;\r\n        const startX = Math.floor(this.camera.x / gridSize) * gridSize;\r\n        const startY = Math.floor(this.camera.y / gridSize) * gridSize;\r\n\r\n        for (let x = startX; x < this.camera.x + this.canvas.width; x += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(x - this.camera.x, 0);\r\n            this.ctx.lineTo(x - this.camera.x, this.canvas.height);\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        for (let y = startY; y < this.camera.y + this.canvas.height; y += gridSize) {\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(0, y - this.camera.y);\r\n            this.ctx.lineTo(this.canvas.width, y - this.camera.y);\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawFood() {\r\n        this.food.forEach(food => {\r\n            const x = food.x - this.camera.x;\r\n            const y = food.y - this.camera.y;\r\n\r\n            if (x > -20 && x < this.canvas.width + 20 && y > -20 && y < this.canvas.height + 20) {\r\n                // Check if food is being vacuumed\r\n                let beingVacuumed = false;\r\n                let closestSnake = null;\r\n                let minDistance = Infinity;\r\n                const allSnakes = [this.player, ...this.aiSnakes].filter(s => s.alive);\r\n\r\n                allSnakes.forEach(snake => {\r\n                    const dist = Math.hypot(food.x - snake.x, food.y - snake.y);\r\n                    const vacuumRadius = snake.size * 3.5;\r\n                    if (dist < vacuumRadius && dist > snake.size + food.size) {\r\n                        beingVacuumed = true;\r\n                        if (dist < minDistance) {\r\n                            minDistance = dist;\r\n                            closestSnake = snake;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                // Draw vacuum trail if being pulled\r\n                if (beingVacuumed && closestSnake) {\r\n                    this.drawVacuumTrail(food, closestSnake, x, y);\r\n                }\r\n\r\n                // Draw enhanced vacuum effect\r\n                if (beingVacuumed) {\r\n                    const time = Date.now() * 0.005;\r\n                    const pulseSize = food.size * 3 + Math.sin(time * 3) * food.size;\r\n                    const pulseAlpha = 0.4 + Math.sin(time * 2) * 0.2;\r\n\r\n                    const glowGradient = this.ctx.createRadialGradient(x, y, 0, x, y, pulseSize);\r\n                    glowGradient.addColorStop(0, food.color);\r\n                    glowGradient.addColorStop(0.3, this.addAlpha(food.color, pulseAlpha));\r\n                    glowGradient.addColorStop(0.7, this.addAlpha('#ffffff', pulseAlpha * 0.5));\r\n                    glowGradient.addColorStop(1, 'transparent');\r\n\r\n                    this.ctx.fillStyle = glowGradient;\r\n                    this.ctx.beginPath();\r\n                    this.ctx.arc(x, y, pulseSize, 0, Math.PI * 2);\r\n                    this.ctx.fill();\r\n\r\n                    // Add vacuum ring indicator\r\n                    this.ctx.strokeStyle = this.addAlpha('#ffffff', pulseAlpha);\r\n                    this.ctx.lineWidth = 1;\r\n                    this.ctx.setLineDash([2, 2]);\r\n                    this.ctx.beginPath();\r\n                    this.ctx.arc(x, y, pulseSize * 0.7, 0, Math.PI * 2);\r\n                    this.ctx.stroke();\r\n                    this.ctx.setLineDash([]);\r\n                }\r\n\r\n                // Draw regular colorful food\r\n                const foodSize = beingVacuumed ? food.size * 1.2 : food.size;\r\n\r\n                // Draw food with glow effect\r\n                const glowGradient = this.ctx.createRadialGradient(x, y, 0, x, y, foodSize * 1.5);\r\n                glowGradient.addColorStop(0, food.color);\r\n                glowGradient.addColorStop(0.7, this.addAlpha(food.color, 0.8));\r\n                glowGradient.addColorStop(1, 'transparent');\r\n\r\n                this.ctx.fillStyle = glowGradient;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, foodSize * 1.5, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Draw main food body\r\n                this.ctx.fillStyle = food.color;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, foodSize, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Add highlight\r\n                this.ctx.fillStyle = this.addAlpha('#ffffff', 0.6);\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x - foodSize * 0.3, y - foodSize * 0.3, foodSize * 0.3, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Add outline\r\n                this.ctx.strokeStyle = beingVacuumed ? '#ffffff' : this.addAlpha(food.color, 0.8);\r\n                this.ctx.lineWidth = beingVacuumed ? 2 : 1;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, foodSize, 0, Math.PI * 2);\r\n                this.ctx.stroke();\r\n            }\r\n        });\r\n    }\r\n\r\n    drawVacuumTrail(food, snake, foodX, foodY) {\r\n        const headX = snake.x - this.camera.x;\r\n        const headY = snake.y - this.camera.y;\r\n\r\n        // Calculate direction from food to snake head\r\n        const dx = headX - foodX;\r\n        const dy = headY - foodY;\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (distance === 0) return;\r\n\r\n        const normalizedDx = dx / distance;\r\n        const normalizedDy = dy / distance;\r\n\r\n        // Draw multiple particle trails\r\n        const numParticles = 6;\r\n        const time = Date.now() * 0.01;\r\n\r\n        for (let i = 0; i < numParticles; i++) {\r\n            const progress = (i / numParticles) + (time % 1);\r\n            const trailProgress = progress % 1;\r\n\r\n            const trailX = foodX + normalizedDx * distance * trailProgress;\r\n            const trailY = foodY + normalizedDy * distance * trailProgress;\r\n\r\n            const alpha = 1 - trailProgress;\r\n            const size = 2 * alpha;\r\n\r\n            if (size > 0.1) {\r\n                this.ctx.fillStyle = this.addAlpha(food.color, alpha * 0.8);\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(trailX, trailY, size, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n            }\r\n        }\r\n\r\n        // Draw main vacuum line\r\n        const lineAlpha = 0.3 + Math.sin(time * 0.5) * 0.2;\r\n        this.ctx.strokeStyle = this.addAlpha(snake.color, lineAlpha);\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.setLineDash([5, 3]);\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(foodX, foodY);\r\n        this.ctx.lineTo(headX, headY);\r\n        this.ctx.stroke();\r\n        this.ctx.setLineDash([]);\r\n    }\r\n\r\n    drawGlowOrbs() {\r\n        this.glowOrbs.forEach(orb => {\r\n            const x = orb.x - this.camera.x;\r\n            const y = orb.y - this.camera.y;\r\n\r\n            if (x > -50 && x < this.canvas.width + 50 && y > -50 && y < this.canvas.height + 50) {\r\n                const time = Date.now() * 0.001;\r\n                const glowSize = orb.size + Math.sin(orb.glow) * 4;\r\n                const baseColor = `hsl(${orb.hue}, 100%, 70%)`;\r\n\r\n                // 5-layer aura system\r\n                // Outer aura (largest)\r\n                const outerAura = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize * 4);\r\n                outerAura.addColorStop(0, `hsla(${orb.hue}, 100%, 70%, 0.1)`);\r\n                outerAura.addColorStop(0.5, `hsla(${orb.hue}, 100%, 70%, 0.05)`);\r\n                outerAura.addColorStop(1, 'transparent');\r\n\r\n                this.ctx.fillStyle = outerAura;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 4, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Middle glow\r\n                const middleGlow = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize * 3);\r\n                middleGlow.addColorStop(0, `hsla(${orb.hue}, 100%, 70%, 0.3)`);\r\n                middleGlow.addColorStop(0.5, `hsla(${orb.hue}, 100%, 70%, 0.2)`);\r\n                middleGlow.addColorStop(1, 'transparent');\r\n\r\n                this.ctx.fillStyle = middleGlow;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 3, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Inner glow\r\n                const innerGlow = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize * 2);\r\n                innerGlow.addColorStop(0, `hsla(${orb.hue}, 100%, 70%, 0.8)`);\r\n                innerGlow.addColorStop(0.6, `hsla(${orb.hue}, 100%, 70%, 0.4)`);\r\n                innerGlow.addColorStop(1, 'transparent');\r\n\r\n                this.ctx.fillStyle = innerGlow;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 2, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Core glow\r\n                const coreGlow = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize);\r\n                coreGlow.addColorStop(0, '#ffffff');\r\n                coreGlow.addColorStop(0.5, baseColor);\r\n                coreGlow.addColorStop(1, `hsla(${orb.hue}, 100%, 70%, 0.7)`);\r\n\r\n                this.ctx.fillStyle = coreGlow;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Ultra-bright core\r\n                this.ctx.fillStyle = '#ffffff';\r\n\r\n                // Draw 12 rotating sparkles\r\n                for (let i = 0; i < 12; i++) {\r\n                    const sparkleAngle = (time * 2 + (i * Math.PI / 6)) % (Math.PI * 2);\r\n                    const sparkleDistance = glowSize * 1.5;\r\n                    const sparkleX = x + Math.cos(sparkleAngle) * sparkleDistance;\r\n                    const sparkleY = y + Math.sin(sparkleAngle) * sparkleDistance;\r\n\r\n                    // Sparkle size pulsation\r\n                    const sparkleSize = 2 + Math.sin(time * 4 + i) * 1;\r\n\r\n                    this.ctx.fillStyle = `hsla(${orb.hue}, 100%, 90%, ${0.7 + Math.sin(time * 3 + i) * 0.3})`;\r\n                    this.ctx.beginPath();\r\n                    this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);\r\n                    this.ctx.fill();\r\n                }\r\n\r\n                // Draw 3 animated energy rings\r\n                for (let i = 0; i < 3; i++) {\r\n                    const ringRadius = glowSize * (1.5 + i * 0.5);\r\n                    const dashOffset = time * (1 + i) * 50;\r\n\r\n                    this.ctx.strokeStyle = `hsla(${orb.hue}, 100%, 80%, ${0.4 - i * 0.1})`;\r\n                    this.ctx.lineWidth = 2;\r\n                    this.ctx.setLineDash([10, 10]);\r\n                    this.ctx.lineDashOffset = dashOffset;\r\n\r\n                    this.ctx.beginPath();\r\n                    this.ctx.arc(x, y, ringRadius, 0, Math.PI * 2);\r\n                    this.ctx.stroke();\r\n                }\r\n\r\n                // Color-shifting effect\r\n                const shiftedHue = (orb.hue + time * 20) % 360;\r\n                const shiftedColor = `hsla(${shiftedHue}, 100%, 70%, 0.3)`;\r\n\r\n                const shiftGlow = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize * 2.5);\r\n                shiftGlow.addColorStop(0, 'transparent');\r\n                shiftGlow.addColorStop(0.5, shiftedColor);\r\n                shiftGlow.addColorStop(1, 'transparent');\r\n\r\n                this.ctx.fillStyle = shiftGlow;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 2.5, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Reset line dash\r\n                this.ctx.setLineDash([]);\r\n\r\n                // Draw glowing orb core\r\n                const coreGradient = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize * 0.8);\r\n                coreGradient.addColorStop(0, `hsla(${orb.hue}, 100%, 90%, 1)`);\r\n                coreGradient.addColorStop(0.5, `hsla(${orb.hue}, 100%, 70%, 0.8)`);\r\n                coreGradient.addColorStop(1, `hsla(${orb.hue}, 100%, 50%, 0.4)`);\r\n\r\n                this.ctx.fillStyle = coreGradient;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 0.8, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Draw inner bright core\r\n                this.ctx.fillStyle = `hsla(${orb.hue}, 100%, 95%, 0.9)`;\r\n                this.ctx.beginPath();\r\n                this.ctx.arc(x, y, glowSize * 0.4, 0, Math.PI * 2);\r\n                this.ctx.fill();\r\n\r\n                // Draw energy symbol in center\r\n                this.ctx.fillStyle = `hsla(${orb.hue}, 100%, 30%, 0.8)`;\r\n                this.ctx.font = `${glowSize * 0.8}px monospace`;\r\n                this.ctx.textAlign = 'center';\r\n                this.ctx.textBaseline = 'middle';\r\n                this.ctx.fillText('⚡', x, y);\r\n\r\n                // Draw sparkle effect\r\n                for (let i = 0; i < 6; i++) {\r\n                    const sparkleAngle = (orb.glow + i * Math.PI / 3) % (Math.PI * 2);\r\n                    const sparkleDistance = glowSize * 1.8;\r\n                    const sparkleX = x + Math.cos(sparkleAngle) * sparkleDistance;\r\n                    const sparkleY = y + Math.sin(sparkleAngle) * sparkleDistance;\r\n\r\n                    this.ctx.fillStyle = `hsla(${orb.hue}, 100%, 80%, 0.8)`;\r\n                    this.ctx.beginPath();\r\n                    this.ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);\r\n                    this.ctx.fill();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    drawSnakes() {\r\n        // Draw all snakes (player + remote players in multiplayer)\r\n        const allSnakes = [this.player, ...this.remotePlayers].filter(s => s.alive);\r\n\r\n        allSnakes.forEach(snake => {\r\n            this.drawRealisticSnake(snake);\r\n        });\r\n    }\r\n\r\n    drawRealisticSnake(snake) {\r\n        if (snake.segments.length < 2) return;\r\n\r\n        // Get head position for effects\r\n        const headX = snake.segments[0].x - this.camera.x;\r\n        const headY = snake.segments[0].y - this.camera.y;\r\n\r\n        // Skip if snake is off-screen\r\n        if (headX < -200 || headX > this.canvas.width + 200 || headY < -200 || headY > this.canvas.height + 200) {\r\n            return;\r\n        }\r\n\r\n        // Check if snake is invincible and should blink\r\n        // Remote players don't have isInvincible method, so check if it exists\r\n        const isInvincible = (typeof snake.isInvincible === 'function') ? snake.isInvincible() : (snake.isInvincible || false);\r\n        const shouldBlink = isInvincible && Math.sin(snake.blinkPhase || 0) < 0;\r\n\r\n        // Skip drawing if blinking (creates blinking effect)\r\n        if (shouldBlink) {\r\n            // Still draw wager display even when blinking\r\n            this.drawWagerDisplay(snake);\r\n            return;\r\n        }\r\n\r\n        // Draw invincibility glow effect\r\n        if (isInvincible) {\r\n            const invincibilityGlow = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, snake.size * 4);\r\n            invincibilityGlow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');\r\n            invincibilityGlow.addColorStop(0.5, 'rgba(0, 255, 255, 0.2)');\r\n            invincibilityGlow.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = invincibilityGlow;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(headX, headY, snake.size * 4, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Draw boost effect for player\r\n        if (snake === this.player && this.boosting) {\r\n            const boostGlow = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, snake.size * 3);\r\n            boostGlow.addColorStop(0, '#ffffff');\r\n            boostGlow.addColorStop(0.3, snake.color);\r\n            boostGlow.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = boostGlow;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(headX, headY, snake.size * 3, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Draw snake body using overlapping circles for smooth appearance\r\n        this.drawSmoothSnakeBody(snake);\r\n\r\n        // Add snake pattern/scales\r\n        this.drawSnakePattern(snake);\r\n\r\n        // Draw the head details\r\n        this.drawSnakeHead(snake);\r\n\r\n        // Draw wager display (both modes have gambling mechanics)\r\n        this.drawWagerDisplay(snake);\r\n    }\r\n\r\n    drawSmoothSnakeBody(snake) {\r\n        // Draw the snake as ONE unified fluid shape with wider head\r\n\r\n        // Step 1: Draw the unified golden outline - body first, then wider head\r\n        this.ctx.strokeStyle = snake.color; // Golden outline\r\n        this.ctx.lineCap = 'round';\r\n        this.ctx.lineJoin = 'round';\r\n\r\n        // Draw body outline\r\n        this.ctx.lineWidth = snake.size * 2.0;\r\n        this.ctx.beginPath();\r\n        for (let i = 1; i < snake.segments.length; i++) { // Start from segment 1 (skip head)\r\n            const segment = snake.segments[i];\r\n            const x = segment.x - this.camera.x;\r\n            const y = segment.y - this.camera.y;\r\n\r\n            if (i === 1) {\r\n                this.ctx.moveTo(x, y);\r\n            } else {\r\n                this.ctx.lineTo(x, y);\r\n            }\r\n        }\r\n        this.ctx.stroke();\r\n\r\n        // Draw wider head outline (serpent-like)\r\n        const head = snake.segments[0];\r\n        const headX = head.x - this.camera.x;\r\n        const headY = head.y - this.camera.y;\r\n\r\n        this.ctx.lineWidth = snake.size * 2.8; // Much wider for head\r\n        this.ctx.beginPath();\r\n\r\n        // Connect head to body if there's a second segment\r\n        if (snake.segments.length > 1) {\r\n            const neck = snake.segments[1];\r\n            const neckX = neck.x - this.camera.x;\r\n            const neckY = neck.y - this.camera.y;\r\n\r\n            this.ctx.moveTo(neckX, neckY);\r\n            this.ctx.lineTo(headX, headY);\r\n        } else {\r\n            // Just draw head if only one segment\r\n            this.ctx.moveTo(headX, headY);\r\n            this.ctx.lineTo(headX, headY);\r\n        }\r\n        this.ctx.stroke();\r\n\r\n        // Step 2: Fill the interior with black - body first\r\n        this.ctx.strokeStyle = '#000000'; // Black interior\r\n        this.ctx.lineWidth = snake.size * 1.6;\r\n        this.ctx.beginPath();\r\n        for (let i = 1; i < snake.segments.length; i++) {\r\n            const segment = snake.segments[i];\r\n            const x = segment.x - this.camera.x;\r\n            const y = segment.y - this.camera.y;\r\n\r\n            if (i === 1) {\r\n                this.ctx.moveTo(x, y);\r\n            } else {\r\n                this.ctx.lineTo(x, y);\r\n            }\r\n        }\r\n        this.ctx.stroke();\r\n\r\n        // Fill head interior with black (wider)\r\n        this.ctx.lineWidth = snake.size * 2.4; // Wider black fill for head\r\n        this.ctx.beginPath();\r\n        if (snake.segments.length > 1) {\r\n            const neck = snake.segments[1];\r\n            const neckX = neck.x - this.camera.x;\r\n            const neckY = neck.y - this.camera.y;\r\n\r\n            this.ctx.moveTo(neckX, neckY);\r\n            this.ctx.lineTo(headX, headY);\r\n        } else {\r\n            this.ctx.moveTo(headX, headY);\r\n            this.ctx.lineTo(headX, headY);\r\n        }\r\n        this.ctx.stroke();\r\n\r\n        // Step 3: Add golden center dots to each segment position\r\n        for (let i = 0; i < snake.segments.length; i++) {\r\n            const segment = snake.segments[i];\r\n            const x = segment.x - this.camera.x;\r\n            const y = segment.y - this.camera.y;\r\n\r\n            // Skip if segment is off-screen\r\n            if (x < -100 || x > this.canvas.width + 100 || y < -100 || y > this.canvas.height + 100) {\r\n                continue;\r\n            }\r\n\r\n            // Dot size - larger for head\r\n            const dotSize = i === 0 ? snake.size * 0.25 : snake.size * 0.15;\r\n\r\n            this.ctx.fillStyle = snake.color; // Golden dots\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, y, dotSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n    }\r\n\r\n\r\n\r\n    drawSnakePattern(snake) {\r\n        const time = Date.now() * 0.001;\r\n\r\n        // Draw massive pulsating aura around entire snake\r\n        for (let i = 0; i < snake.segments.length; i += 3) {\r\n            const segment = snake.segments[i];\r\n            const x = segment.x - this.camera.x;\r\n            const y = segment.y - this.camera.y;\r\n\r\n            if (x < -100 || x > this.canvas.width + 100 || y < -100 || y > this.canvas.height + 100) {\r\n                continue;\r\n            }\r\n\r\n            const segmentRatio = 1 - (i / snake.segments.length) * 0.4;\r\n            const segmentSize = snake.size * segmentRatio;\r\n            const auraSize = segmentSize * (2.5 + Math.sin(time * 2 + i * 0.1) * 0.3);\r\n\r\n            // Create pulsating aura\r\n            const auraGradient = this.ctx.createRadialGradient(x, y, 0, x, y, auraSize);\r\n            auraGradient.addColorStop(0, this.addAlpha(snake.color, 0.2));\r\n            auraGradient.addColorStop(0.5, this.addAlpha(snake.color, 0.1));\r\n            auraGradient.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = auraGradient;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(x, y, auraSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Draw hexagonal scales with metallic effect\r\n        for (let i = 0; i < snake.segments.length - 1; i += 2) {\r\n            const segment = snake.segments[i];\r\n            const x = segment.x - this.camera.x;\r\n            const y = segment.y - this.camera.y;\r\n\r\n            if (x < -100 || x > this.canvas.width + 100 || y < -100 || y > this.canvas.height + 100) {\r\n                continue;\r\n            }\r\n\r\n            const segmentRatio = 1 - (i / snake.segments.length) * 0.4;\r\n            const segmentSize = snake.size * segmentRatio;\r\n            const scaleSize = segmentSize * 0.4;\r\n            const angle = snake.angle + (i * 0.1) + Math.sin(time + i * 0.2) * 0.1; // Dynamic rotation\r\n\r\n            this.ctx.save();\r\n            this.ctx.translate(x, y);\r\n            this.ctx.rotate(angle);\r\n\r\n            // Draw hexagonal scales\r\n            const hexPoints = [];\r\n            for (let j = 0; j < 6; j++) {\r\n                const scaleAngle = (j * Math.PI / 3);\r\n                hexPoints.push({\r\n                    x: Math.cos(scaleAngle) * scaleSize,\r\n                    y: Math.sin(scaleAngle) * scaleSize\r\n                });\r\n            }\r\n\r\n            // Metallic gradient for scales\r\n            const scaleGradient = this.ctx.createRadialGradient(\r\n                -scaleSize * 0.2, -scaleSize * 0.2, 0,\r\n                0, 0, scaleSize\r\n            );\r\n            scaleGradient.addColorStop(0, '#ffffff');\r\n            scaleGradient.addColorStop(0.3, snake.color);\r\n            scaleGradient.addColorStop(0.6, this.darkenColor(snake.color, 0.2));\r\n            scaleGradient.addColorStop(0.8, snake.color);\r\n            scaleGradient.addColorStop(1, this.darkenColor(snake.color, 0.3));\r\n\r\n            // Draw scale with shimmer effect\r\n            this.ctx.fillStyle = scaleGradient;\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(hexPoints[0].x, hexPoints[0].y);\r\n            for (let j = 1; j < hexPoints.length; j++) {\r\n                this.ctx.lineTo(hexPoints[j].x, hexPoints[j].y);\r\n            }\r\n            this.ctx.closePath();\r\n            this.ctx.fill();\r\n\r\n            // Add dynamic shine effect\r\n            const shineOpacity = Math.max(0, Math.sin(time * 3 + i * 0.2)) * 0.4;\r\n            this.ctx.fillStyle = this.addAlpha('#ffffff', shineOpacity);\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(-scaleSize * 0.2, -scaleSize * 0.2, scaleSize * 0.3, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            this.ctx.restore();\r\n        }\r\n    }\r\n\r\n    drawSnakeHead(snake) {\r\n        const head = snake.segments[0];\r\n        const x = head.x - this.camera.x;\r\n        const y = head.y - this.camera.y;\r\n\r\n        if (x < -100 || x > this.canvas.width + 100 || y < -100 || y > this.canvas.height + 100) {\r\n            return;\r\n        }\r\n\r\n        const time = Date.now() * 0.001;\r\n        const headSize = snake.size * 1.2;\r\n        const eyeSize = headSize * 0.3;\r\n        const eyeOffset = headSize * 0.5;\r\n\r\n        // Draw massive pulsating aura\r\n        const auraSize = headSize * (3 + Math.sin(time * 2) * 0.5);\r\n        const auraGradient = this.ctx.createRadialGradient(x, y, 0, x, y, auraSize);\r\n        auraGradient.addColorStop(0, this.addAlpha(snake.color, 0.4));\r\n        auraGradient.addColorStop(0.5, this.addAlpha(snake.color, 0.2));\r\n        auraGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = auraGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, auraSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Draw battering ram comet effect if active\r\n        // Remote players don't have hasActivePowerup method\r\n        const hasBatteringRam = (typeof snake.hasActivePowerup === 'function') ?\r\n            snake.hasActivePowerup('battering_ram') :\r\n            (snake.activePowerups && snake.activePowerups.some(p => p.type === 'battering_ram'));\r\n        if (hasBatteringRam) {\r\n            this.drawBatteringRamEffect(snake, x, y, headSize);\r\n        }\r\n\r\n        // Head is already drawn in drawSmoothSnakeBody as part of unified shape\r\n        // Just add eyes here\r\n\r\n        // Draw all active powerup effects\r\n        this.drawActivePowerupEffects(snake, x, y, headSize);\r\n\r\n        // Add dynamic glow effect\r\n        const glowSize = headSize * (1.5 + Math.sin(time * 3) * 0.2);\r\n        const glowGradient = this.ctx.createRadialGradient(x, y, headSize * 0.8, x, y, glowSize);\r\n        glowGradient.addColorStop(0, this.addAlpha(snake.color, 0.5));\r\n        glowGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = glowGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, glowSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Draw glowing cyan eyes with red pupils\r\n        const eyeAngle = snake.angle;\r\n        const eyeDistance = headSize * 0.5;\r\n\r\n        for (let i = -1; i <= 1; i += 2) {\r\n            const eyeX = x + Math.cos(eyeAngle + Math.PI/2) * eyeDistance * i;\r\n            const eyeY = y + Math.sin(eyeAngle + Math.PI/2) * eyeDistance * i;\r\n\r\n            // Eye glow\r\n            const eyeGlow = this.ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, eyeSize * 1.5);\r\n            eyeGlow.addColorStop(0, 'rgba(0, 255, 255, 0.8)');\r\n            eyeGlow.addColorStop(0.5, 'rgba(0, 255, 255, 0.4)');\r\n            eyeGlow.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = eyeGlow;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(eyeX, eyeY, eyeSize * 1.5, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Eye white\r\n            this.ctx.fillStyle = '#00ffff';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Red pupil with glow\r\n            const pupilSize = eyeSize * 0.5;\r\n            const pupilX = eyeX + Math.cos(eyeAngle) * eyeSize * 0.2;\r\n            const pupilY = eyeY + Math.sin(eyeAngle) * eyeSize * 0.2;\r\n\r\n            const pupilGlow = this.ctx.createRadialGradient(pupilX, pupilY, 0, pupilX, pupilY, pupilSize * 1.5);\r\n            pupilGlow.addColorStop(0, '#ff0000');\r\n            pupilGlow.addColorStop(0.5, 'rgba(255, 0, 0, 0.5)');\r\n            pupilGlow.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = pupilGlow;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(pupilX, pupilY, pupilSize * 1.5, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            this.ctx.fillStyle = '#ff0000';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(pupilX, pupilY, pupilSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Shine effect\r\n            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(eyeX - eyeSize * 0.2, eyeY - eyeSize * 0.2, eyeSize * 0.1, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Draw forked tongue occasionally\r\n        if (Math.sin(time * 4) > 0.7) {\r\n            const tongueLength = headSize * 2;\r\n            const tongueWidth = headSize * 0.15;\r\n            const tongueAngle = eyeAngle;\r\n            const tongueStartX = x + Math.cos(tongueAngle) * headSize;\r\n            const tongueStartY = y + Math.sin(tongueAngle) * headSize;\r\n            const tongueEndX = tongueStartX + Math.cos(tongueAngle) * tongueLength;\r\n            const tongueEndY = tongueStartY + Math.sin(tongueAngle) * tongueLength;\r\n            const forkLength = tongueLength * 0.3;\r\n\r\n            this.ctx.strokeStyle = '#ff3366';\r\n            this.ctx.lineWidth = tongueWidth;\r\n            this.ctx.lineCap = 'round';\r\n\r\n            // Main tongue\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(tongueStartX, tongueStartY);\r\n            this.ctx.lineTo(tongueEndX, tongueEndY);\r\n            this.ctx.stroke();\r\n\r\n            // Forked ends\r\n            const forkAngle = Math.PI / 4;\r\n            for (let i = -1; i <= 1; i += 2) {\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(tongueEndX, tongueEndY);\r\n                this.ctx.lineTo(\r\n                    tongueEndX + Math.cos(tongueAngle + forkAngle * i) * forkLength,\r\n                    tongueEndY + Math.sin(tongueAngle + forkAngle * i) * forkLength\r\n                );\r\n                this.ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw vacuum radius indicator\r\n        this.drawVacuumIndicator(snake, x, y);\r\n\r\n        // Draw crown if this snake is the king\r\n        if (this.currentKing === snake) {\r\n            this.drawCrown(snake, x, y, headSize);\r\n        }\r\n\r\n        // Eye pupils\r\n        this.ctx.fillStyle = '#000';\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(eyeOffset * 0.7, -eyeOffset * 0.6, eyeSize * 0.6, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(eyeOffset * 0.7, eyeOffset * 0.6, eyeSize * 0.6, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Eye shine\r\n        this.ctx.fillStyle = '#ffffff';\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(eyeOffset * 0.7 - eyeSize * 0.3, -eyeOffset * 0.6 - eyeSize * 0.3, eyeSize * 0.2, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(eyeOffset * 0.7 - eyeSize * 0.3, eyeOffset * 0.6 - eyeSize * 0.3, eyeSize * 0.2, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Nostrils\r\n        this.ctx.fillStyle = this.darkenColor(snake.color, 0.6);\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headSize * 0.9, -headSize * 0.2, headSize * 0.08, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headSize * 0.9, headSize * 0.2, headSize * 0.08, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawBatteringRamEffect(snake, headX, headY, headSize) {\r\n        const time = Date.now() * 0.001;\r\n\r\n        // Calculate direction snake is moving\r\n        const angle = snake.angle;\r\n        const cometLength = headSize * 3;\r\n\r\n        // Draw comet trail behind the head\r\n        const trailPoints = [];\r\n        const numTrailPoints = 8;\r\n\r\n        for (let i = 0; i < numTrailPoints; i++) {\r\n            const progress = i / numTrailPoints;\r\n            const trailDistance = cometLength * progress;\r\n            const trailX = headX - Math.cos(angle) * trailDistance;\r\n            const trailY = headY - Math.sin(angle) * trailDistance;\r\n            const trailSize = headSize * (1 - progress * 0.8);\r\n\r\n            trailPoints.push({ x: trailX, y: trailY, size: trailSize, progress });\r\n        }\r\n\r\n        // Draw trail with gradient\r\n        this.ctx.save();\r\n\r\n        // Create comet trail gradient\r\n        const trailGradient = this.ctx.createLinearGradient(\r\n            headX, headY,\r\n            headX - Math.cos(angle) * cometLength,\r\n            headY - Math.sin(angle) * cometLength\r\n        );\r\n        trailGradient.addColorStop(0, '#FF6600FF'); // Bright orange at head\r\n        trailGradient.addColorStop(0.3, '#FF9933AA'); // Medium orange\r\n        trailGradient.addColorStop(0.7, '#FFCC6666'); // Light orange\r\n        trailGradient.addColorStop(1, 'transparent'); // Fade to transparent\r\n\r\n        // Draw comet body\r\n        this.ctx.fillStyle = trailGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(headX, headY);\r\n\r\n        // Create comet shape\r\n        const cometWidth = headSize * 0.8;\r\n        const perpAngle = angle + Math.PI / 2;\r\n\r\n        // Top edge of comet\r\n        this.ctx.lineTo(\r\n            headX + Math.cos(perpAngle) * cometWidth / 2,\r\n            headY + Math.sin(perpAngle) * cometWidth / 2\r\n        );\r\n        this.ctx.lineTo(\r\n            headX - Math.cos(angle) * cometLength + Math.cos(perpAngle) * cometWidth / 4,\r\n            headY - Math.sin(angle) * cometLength + Math.sin(perpAngle) * cometWidth / 4\r\n        );\r\n\r\n        // Tail point\r\n        this.ctx.lineTo(\r\n            headX - Math.cos(angle) * cometLength,\r\n            headY - Math.sin(angle) * cometLength\r\n        );\r\n\r\n        // Bottom edge of comet\r\n        this.ctx.lineTo(\r\n            headX - Math.cos(angle) * cometLength - Math.cos(perpAngle) * cometWidth / 4,\r\n            headY - Math.sin(angle) * cometLength - Math.sin(perpAngle) * cometWidth / 4\r\n        );\r\n        this.ctx.lineTo(\r\n            headX - Math.cos(perpAngle) * cometWidth / 2,\r\n            headY - Math.sin(perpAngle) * cometWidth / 2\r\n        );\r\n\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        // Add sparks and particles\r\n        for (let i = 0; i < 6; i++) {\r\n            const sparkAngle = angle + (Math.random() - 0.5) * Math.PI / 2;\r\n            const sparkDistance = headSize * (1 + Math.random() * 2);\r\n            const sparkX = headX - Math.cos(sparkAngle) * sparkDistance;\r\n            const sparkY = headY - Math.sin(sparkAngle) * sparkDistance;\r\n            const sparkSize = 2 + Math.random() * 3;\r\n\r\n            this.ctx.fillStyle = '#FFAA00';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Add energy glow around head\r\n        const energyGlow = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, headSize * 2);\r\n        energyGlow.addColorStop(0, '#FF660080');\r\n        energyGlow.addColorStop(0.5, '#FF990040');\r\n        energyGlow.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = energyGlow;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, headSize * 2, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawHelmet(snake, headX, headY, headSize) {\r\n        const time = Date.now() * 0.001;\r\n        // Remote players don't have getHelmetHealth method\r\n        const helmetHealth = (typeof snake.getHelmetHealth === 'function') ? snake.getHelmetHealth() : 500;\r\n        const maxHelmetHealth = 500;\r\n        const healthRatio = helmetHealth / maxHelmetHealth;\r\n\r\n        // Helmet size slightly larger than head\r\n        const helmetSize = headSize * 1.15;\r\n\r\n        this.ctx.save();\r\n\r\n        // Helmet base color changes based on health\r\n        let helmetColor = '#888888';\r\n        if (healthRatio < 0.3) {\r\n            helmetColor = '#AA4444'; // Red when damaged\r\n        } else if (healthRatio < 0.6) {\r\n            helmetColor = '#AAAA44'; // Yellow when moderately damaged\r\n        }\r\n\r\n        // Draw helmet dome\r\n        const helmetGradient = this.ctx.createRadialGradient(\r\n            headX - helmetSize * 0.3, headY - helmetSize * 0.3, 0,\r\n            headX, headY, helmetSize\r\n        );\r\n        helmetGradient.addColorStop(0, '#FFFFFF');\r\n        helmetGradient.addColorStop(0.3, helmetColor);\r\n        helmetGradient.addColorStop(0.7, this.darkenColor(helmetColor, 0.3));\r\n        helmetGradient.addColorStop(1, this.darkenColor(helmetColor, 0.5));\r\n\r\n        this.ctx.fillStyle = helmetGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, helmetSize, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Helmet visor (darker area)\r\n        const visorGradient = this.ctx.createRadialGradient(\r\n            headX, headY - helmetSize * 0.2, 0,\r\n            headX, headY, helmetSize * 0.8\r\n        );\r\n        visorGradient.addColorStop(0, '#333333AA');\r\n        visorGradient.addColorStop(0.5, '#555555AA');\r\n        visorGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = visorGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, helmetSize * 0.8, 0, Math.PI, true);\r\n        this.ctx.fill();\r\n\r\n        // Helmet outline\r\n        this.ctx.strokeStyle = this.darkenColor(helmetColor, 0.4);\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, helmetSize, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n\r\n        // Add damage cracks if helmet is damaged\r\n        if (healthRatio < 0.8) {\r\n            this.ctx.strokeStyle = '#222222';\r\n            this.ctx.lineWidth = 1;\r\n\r\n            // Draw random cracks\r\n            const numCracks = Math.floor((1 - healthRatio) * 5);\r\n            for (let i = 0; i < numCracks; i++) {\r\n                const crackAngle = Math.random() * Math.PI * 2;\r\n                const crackLength = helmetSize * (0.3 + Math.random() * 0.4);\r\n                const startX = headX + Math.cos(crackAngle) * helmetSize * 0.3;\r\n                const startY = headY + Math.sin(crackAngle) * helmetSize * 0.3;\r\n                const endX = startX + Math.cos(crackAngle + (Math.random() - 0.5) * 0.5) * crackLength;\r\n                const endY = startY + Math.sin(crackAngle + (Math.random() - 0.5) * 0.5) * crackLength;\r\n\r\n                this.ctx.beginPath();\r\n                this.ctx.moveTo(startX, startY);\r\n                this.ctx.lineTo(endX, endY);\r\n                this.ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Helmet health indicator (small bar above helmet)\r\n        const barWidth = helmetSize * 1.5;\r\n        const barHeight = 4;\r\n        const barX = headX - barWidth / 2;\r\n        const barY = headY - helmetSize - 15;\r\n\r\n        // Background bar\r\n        this.ctx.fillStyle = '#333333';\r\n        this.ctx.fillRect(barX, barY, barWidth, barHeight);\r\n\r\n        // Health bar\r\n        const healthColor = healthRatio > 0.6 ? '#44AA44' : healthRatio > 0.3 ? '#AAAA44' : '#AA4444';\r\n        this.ctx.fillStyle = healthColor;\r\n        this.ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);\r\n\r\n        // Bar outline\r\n        this.ctx.strokeStyle = '#FFFFFF';\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.strokeRect(barX, barY, barWidth, barHeight);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawCrown(snake, headX, headY, headSize) {\r\n        const crownSize = headSize * 0.8;\r\n        const crownY = headY - headSize * 1.5; // Position above head\r\n\r\n        this.ctx.save();\r\n\r\n        // Crown base (golden band)\r\n        const crownGradient = this.ctx.createLinearGradient(\r\n            headX - crownSize, crownY - crownSize * 0.2,\r\n            headX + crownSize, crownY + crownSize * 0.2\r\n        );\r\n        crownGradient.addColorStop(0, '#FFD700'); // Gold\r\n        crownGradient.addColorStop(0.5, '#FFF700'); // Bright gold\r\n        crownGradient.addColorStop(1, '#FFD700'); // Gold\r\n\r\n        this.ctx.fillStyle = crownGradient;\r\n        this.ctx.fillRect(headX - crownSize, crownY, crownSize * 2, crownSize * 0.4);\r\n\r\n        // Crown spikes\r\n        this.ctx.beginPath();\r\n        const spikeCount = 5;\r\n        const spikeWidth = (crownSize * 2) / spikeCount;\r\n\r\n        for (let i = 0; i < spikeCount; i++) {\r\n            const spikeX = headX - crownSize + (i * spikeWidth);\r\n            const spikeHeight = i === 2 ? crownSize * 0.8 : crownSize * 0.6; // Middle spike taller\r\n\r\n            // Draw spike triangle\r\n            this.ctx.moveTo(spikeX, crownY);\r\n            this.ctx.lineTo(spikeX + spikeWidth / 2, crownY - spikeHeight);\r\n            this.ctx.lineTo(spikeX + spikeWidth, crownY);\r\n        }\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        // Crown gems (red jewels)\r\n        for (let i = 0; i < 3; i++) {\r\n            const gemX = headX - crownSize * 0.6 + (i * crownSize * 0.6);\r\n            const gemY = crownY + crownSize * 0.1;\r\n\r\n            this.ctx.fillStyle = '#FF0000'; // Red gem\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(gemX, gemY, crownSize * 0.1, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Gem highlight\r\n            this.ctx.fillStyle = '#FF6666';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(gemX - crownSize * 0.03, gemY - crownSize * 0.03, crownSize * 0.05, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        // Crown outline\r\n        this.ctx.strokeStyle = '#B8860B'; // Dark gold\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.strokeRect(headX - crownSize, crownY, crownSize * 2, crownSize * 0.4);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawKingIndicator() {\r\n        if (!this.currentKing || !this.player.alive || this.currentKing === this.player) {\r\n            return; // Don't show indicator if no king, player is dead, or player is the king\r\n        }\r\n\r\n        const kingX = this.currentKing.x;\r\n        const kingY = this.currentKing.y;\r\n        const playerX = this.player.x;\r\n        const playerY = this.player.y;\r\n\r\n        // Calculate direction to king\r\n        const dx = kingX - playerX;\r\n        const dy = kingY - playerY;\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (distance < 200) return; // Don't show if king is very close\r\n\r\n        const angle = Math.atan2(dy, dx);\r\n\r\n        // Position indicator at edge of screen\r\n        const centerX = this.canvas.width / 2;\r\n        const centerY = this.canvas.height / 2;\r\n        const radius = Math.min(centerX, centerY) * 0.8; // 80% of screen radius\r\n\r\n        const indicatorX = centerX + Math.cos(angle) * radius;\r\n        const indicatorY = centerY + Math.sin(angle) * radius;\r\n\r\n        this.ctx.save();\r\n\r\n        // Draw arrow pointing to king\r\n        const arrowSize = 20;\r\n        const time = Date.now() * 0.001;\r\n        const pulse = 1 + Math.sin(time * 3) * 0.2; // Pulsing effect\r\n\r\n        // Arrow background (black with gold border)\r\n        this.ctx.fillStyle = '#000000';\r\n        this.ctx.strokeStyle = '#FFD700';\r\n        this.ctx.lineWidth = 3;\r\n\r\n        this.ctx.translate(indicatorX, indicatorY);\r\n        this.ctx.rotate(angle);\r\n        this.ctx.scale(pulse, pulse);\r\n\r\n        // Draw arrow shape\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(arrowSize, 0);\r\n        this.ctx.lineTo(-arrowSize * 0.5, -arrowSize * 0.5);\r\n        this.ctx.lineTo(-arrowSize * 0.3, 0);\r\n        this.ctx.lineTo(-arrowSize * 0.5, arrowSize * 0.5);\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n        this.ctx.stroke();\r\n\r\n        this.ctx.restore();\r\n\r\n        // Draw crown icon next to arrow\r\n        this.ctx.save();\r\n        this.ctx.translate(indicatorX, indicatorY);\r\n\r\n        const crownSize = 12;\r\n        const crownOffset = 30;\r\n        const crownX = Math.cos(angle + Math.PI / 2) * crownOffset;\r\n        const crownY = Math.sin(angle + Math.PI / 2) * crownOffset;\r\n\r\n        // Mini crown\r\n        this.ctx.fillStyle = '#FFD700';\r\n        this.ctx.fillRect(crownX - crownSize, crownY - crownSize * 0.3, crownSize * 2, crownSize * 0.6);\r\n\r\n        // Crown spikes\r\n        this.ctx.beginPath();\r\n        for (let i = 0; i < 3; i++) {\r\n            const spikeX = crownX - crownSize + (i * crownSize * 0.8);\r\n            const spikeHeight = i === 1 ? crownSize * 0.8 : crownSize * 0.6;\r\n\r\n            this.ctx.moveTo(spikeX, crownY - crownSize * 0.3);\r\n            this.ctx.lineTo(spikeX + crownSize * 0.4, crownY - crownSize * 0.3 - spikeHeight);\r\n            this.ctx.lineTo(spikeX + crownSize * 0.8, crownY - crownSize * 0.3);\r\n        }\r\n        this.ctx.closePath();\r\n        this.ctx.fill();\r\n\r\n        // Distance text\r\n        const distanceText = `${Math.floor(distance)}m`;\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.font = '12px monospace';\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.fillText(distanceText, crownX, crownY + crownSize + 15);\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawActivePowerupEffects(snake, headX, headY, headSize) {\r\n        // Draw effects for each active powerup\r\n        // Remote players don't have activePowerups array\r\n        const activePowerups = snake.activePowerups || [];\r\n        activePowerups.forEach(powerup => {\r\n            switch (powerup.type) {\r\n                case 'helmet':\r\n                    this.drawHelmet(snake, headX, headY, headSize);\r\n                    break;\r\n                case 'forcefield':\r\n                    this.drawForcefieldEffect(snake, headX, headY, headSize);\r\n                    break;\r\n                case 'armor_plating':\r\n                    this.drawArmorPlatingEffect(snake, headX, headY, headSize);\r\n                    break;\r\n                case 'shield_generator':\r\n                    this.drawShieldGeneratorEffect(snake, headX, headY, headSize);\r\n                    break;\r\n                // Note: battering_ram effect is drawn separately in drawSnakeHead\r\n            }\r\n        });\r\n\r\n        // Draw powerup status indicators\r\n        this.drawPowerupStatusIndicators(snake, headX, headY, headSize);\r\n    }\r\n\r\n    drawForcefieldEffect(snake, headX, headY, headSize) {\r\n        const time = Date.now() * 0.001;\r\n        const shieldSize = headSize * 2.5;\r\n\r\n        this.ctx.save();\r\n\r\n        // Rotating energy shield\r\n        const rotationSpeed = time * 2;\r\n\r\n        // Multiple shield layers for depth\r\n        for (let layer = 0; layer < 3; layer++) {\r\n            const layerSize = shieldSize * (0.8 + layer * 0.1);\r\n            const layerAlpha = 0.3 - layer * 0.1;\r\n\r\n            this.ctx.save();\r\n            this.ctx.translate(headX, headY);\r\n            this.ctx.rotate(rotationSpeed + layer * Math.PI / 3);\r\n\r\n            // Hexagonal energy shield\r\n            this.ctx.strokeStyle = `rgba(0, 255, 255, ${layerAlpha})`;\r\n            this.ctx.lineWidth = 3;\r\n            this.ctx.setLineDash([10, 5]);\r\n            this.ctx.lineDashOffset = time * 20;\r\n\r\n            this.ctx.beginPath();\r\n            for (let i = 0; i < 6; i++) {\r\n                const angle = (i / 6) * Math.PI * 2;\r\n                const x = Math.cos(angle) * layerSize;\r\n                const y = Math.sin(angle) * layerSize;\r\n                if (i === 0) {\r\n                    this.ctx.moveTo(x, y);\r\n                } else {\r\n                    this.ctx.lineTo(x, y);\r\n                }\r\n            }\r\n            this.ctx.closePath();\r\n            this.ctx.stroke();\r\n\r\n            this.ctx.restore();\r\n        }\r\n\r\n        // Energy particles around shield\r\n        for (let i = 0; i < 8; i++) {\r\n            const particleAngle = (i / 8) * Math.PI * 2 + time;\r\n            const particleDistance = shieldSize * 0.9;\r\n            const particleX = headX + Math.cos(particleAngle) * particleDistance;\r\n            const particleY = headY + Math.sin(particleAngle) * particleDistance;\r\n\r\n            const particleGlow = this.ctx.createRadialGradient(particleX, particleY, 0, particleX, particleY, 8);\r\n            particleGlow.addColorStop(0, '#00FFFF');\r\n            particleGlow.addColorStop(1, 'transparent');\r\n\r\n            this.ctx.fillStyle = particleGlow;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(particleX, particleY, 8, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawArmorPlatingEffect(snake, headX, headY, headSize) {\r\n        const time = Date.now() * 0.001;\r\n\r\n        this.ctx.save();\r\n\r\n        // Metallic armor plates around the snake\r\n        const plateCount = 8;\r\n        const plateSize = headSize * 0.4;\r\n        const plateDistance = headSize * 1.8;\r\n\r\n        for (let i = 0; i < plateCount; i++) {\r\n            const angle = (i / plateCount) * Math.PI * 2 + time * 0.5;\r\n            const plateX = headX + Math.cos(angle) * plateDistance;\r\n            const plateY = headY + Math.sin(angle) * plateDistance;\r\n\r\n            this.ctx.save();\r\n            this.ctx.translate(plateX, plateY);\r\n            this.ctx.rotate(angle + Math.PI / 2);\r\n\r\n            // Armor plate gradient\r\n            const plateGradient = this.ctx.createLinearGradient(-plateSize, -plateSize, plateSize, plateSize);\r\n            plateGradient.addColorStop(0, '#CCCCCC');\r\n            plateGradient.addColorStop(0.5, '#888888');\r\n            plateGradient.addColorStop(1, '#444444');\r\n\r\n            this.ctx.fillStyle = plateGradient;\r\n            this.ctx.strokeStyle = '#FFFFFF';\r\n            this.ctx.lineWidth = 2;\r\n\r\n            // Draw armor plate\r\n            this.ctx.beginPath();\r\n            this.ctx.rect(-plateSize / 2, -plateSize, plateSize, plateSize * 2);\r\n            this.ctx.fill();\r\n            this.ctx.stroke();\r\n\r\n            // Armor rivets\r\n            this.ctx.fillStyle = '#AAAAAA';\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(0, -plateSize * 0.5, 2, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(0, plateSize * 0.5, 2, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            this.ctx.restore();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawShieldGeneratorEffect(snake, headX, headY, headSize) {\r\n        const time = Date.now() * 0.001;\r\n        const shieldRadius = headSize * 3;\r\n\r\n        this.ctx.save();\r\n\r\n        // Powerful energy dome\r\n        const pulseIntensity = 0.7 + Math.sin(time * 4) * 0.3;\r\n\r\n        // Outer energy dome\r\n        const domeGradient = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, shieldRadius);\r\n        domeGradient.addColorStop(0, 'transparent');\r\n        domeGradient.addColorStop(0.8, `rgba(255, 255, 0, ${0.1 * pulseIntensity})`);\r\n        domeGradient.addColorStop(0.95, `rgba(255, 255, 0, ${0.3 * pulseIntensity})`);\r\n        domeGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = domeGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, shieldRadius, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Energy ring pulses\r\n        for (let ring = 0; ring < 3; ring++) {\r\n            const ringTime = time * 2 + ring * Math.PI / 3;\r\n            const ringRadius = shieldRadius * (0.3 + (Math.sin(ringTime) + 1) * 0.35);\r\n            const ringAlpha = Math.max(0, Math.sin(ringTime)) * 0.5;\r\n\r\n            this.ctx.strokeStyle = `rgba(255, 255, 0, ${ringAlpha})`;\r\n            this.ctx.lineWidth = 4;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(headX, headY, ringRadius, 0, Math.PI * 2);\r\n            this.ctx.stroke();\r\n        }\r\n\r\n        // Generator core at center\r\n        const coreGlow = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, headSize * 0.5);\r\n        coreGlow.addColorStop(0, '#FFFF00');\r\n        coreGlow.addColorStop(0.5, '#FFAA00');\r\n        coreGlow.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = coreGlow;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, headSize * 0.5, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawPowerupStatusIndicators(snake, headX, headY, headSize) {\r\n        // Remote players don't have activePowerups array\r\n        const activePowerups = snake.activePowerups || [];\r\n        if (activePowerups.length === 0) return;\r\n\r\n        const time = Date.now() * 0.001;\r\n        const indicatorY = headY - headSize * 2.5;\r\n        let indicatorX = headX - (activePowerups.length * 15) / 2;\r\n\r\n        this.ctx.save();\r\n\r\n        activePowerups.forEach((powerup, index) => {\r\n            const timeRemaining = powerup.expirationTime - Date.now();\r\n            const totalDuration = powerup.duration;\r\n            const timeRatio = timeRemaining / totalDuration;\r\n\r\n            // Indicator background\r\n            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n            this.ctx.fillRect(indicatorX - 8, indicatorY - 8, 16, 16);\r\n\r\n            // Powerup icon color\r\n            let iconColor = '#FFFFFF';\r\n            switch (powerup.type) {\r\n                case 'helmet': iconColor = '#888888'; break;\r\n                case 'forcefield': iconColor = '#00FFFF'; break;\r\n                case 'armor_plating': iconColor = '#CCCCCC'; break;\r\n                case 'battering_ram': iconColor = '#FF6600'; break;\r\n                case 'shield_generator': iconColor = '#FFFF00'; break;\r\n            }\r\n\r\n            // Pulsing effect when time is running low\r\n            if (timeRatio < 0.3) {\r\n                const pulseAlpha = 0.5 + Math.sin(time * 10) * 0.5;\r\n                iconColor = this.addAlpha(iconColor, pulseAlpha);\r\n            }\r\n\r\n            // Draw powerup icon\r\n            this.ctx.fillStyle = iconColor;\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(indicatorX, indicatorY, 6, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n\r\n            // Time remaining bar\r\n            const barWidth = 12;\r\n            const barHeight = 2;\r\n            const barX = indicatorX - barWidth / 2;\r\n            const barY = indicatorY + 10;\r\n\r\n            this.ctx.fillStyle = '#333333';\r\n            this.ctx.fillRect(barX, barY, barWidth, barHeight);\r\n\r\n            const timeColor = timeRatio > 0.5 ? '#44AA44' : timeRatio > 0.2 ? '#AAAA44' : '#AA4444';\r\n            this.ctx.fillStyle = timeColor;\r\n            this.ctx.fillRect(barX, barY, barWidth * timeRatio, barHeight);\r\n\r\n            indicatorX += 30;\r\n        });\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    drawVacuumIndicator(snake, headX, headY) {\r\n        const vacuumRadius = snake.size * 3.5;\r\n        const time = Date.now() * 0.003;\r\n\r\n        // Pulsating vacuum radius circle\r\n        const pulseIntensity = 0.5 + Math.sin(time * 2) * 0.3;\r\n        const alpha = 0.1 + pulseIntensity * 0.1;\r\n\r\n        // Outer vacuum circle\r\n        this.ctx.strokeStyle = this.addAlpha(snake.color, alpha);\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.setLineDash([5, 5]);\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, vacuumRadius * pulseIntensity, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n        this.ctx.setLineDash([]);\r\n\r\n        // Inner vacuum glow\r\n        const vacuumGlow = this.ctx.createRadialGradient(headX, headY, 0, headX, headY, vacuumRadius);\r\n        vacuumGlow.addColorStop(0, 'transparent');\r\n        vacuumGlow.addColorStop(0.7, 'transparent');\r\n        vacuumGlow.addColorStop(0.9, this.addAlpha(snake.color, alpha * 0.5));\r\n        vacuumGlow.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = vacuumGlow;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(headX, headY, vacuumRadius, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n    }\r\n\r\n    drawWagerDisplay(snake) {\r\n        const headX = snake.segments[0].x - this.camera.x;\r\n        const headY = snake.segments[0].y - this.camera.y;\r\n\r\n        // Skip if off-screen\r\n        if (headX < -100 || headX > this.canvas.width + 100 || headY < -100 || headY > this.canvas.height + 100) {\r\n            return;\r\n        }\r\n\r\n        // Show cash balance instead of wager - rounded to 2 decimal places\r\n        const cashBalance = snake.isPlayer ? this.cashBalance : (snake.collectedCash || 0);\r\n        const roundedBalance = parseFloat(cashBalance.toFixed(2));\r\n        const displayY = headY - snake.size - 30; // Position above head\r\n\r\n        // Create bounty chip design\r\n        this.drawBountyChip(headX, displayY, roundedBalance, snake.isPlayer);\r\n    }\r\n\r\n    drawBountyChip(centerX, centerY, amount, isPlayer) {\r\n        // Format the amount text\r\n        const text = `$${amount.toFixed(2)}`;\r\n\r\n        // Dynamic sizing based on amount value\r\n        const baseSize = 20;\r\n        const sizeMultiplier = Math.min(1.5, Math.max(0.8, Math.log10(amount + 1) * 0.3));\r\n        const chipRadius = baseSize * sizeMultiplier;\r\n\r\n        // Animation effects\r\n        const time = Date.now() * 0.001;\r\n        const pulseEffect = Math.sin(time * 2) * 0.1 + 1;\r\n        const glowIntensity = Math.sin(time * 3) * 0.3 + 0.7;\r\n\r\n        this.ctx.save();\r\n\r\n        // Enhanced shadow with blur\r\n        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';\r\n        this.ctx.shadowBlur = 8;\r\n        this.ctx.shadowOffsetX = 2;\r\n        this.ctx.shadowOffsetY = 2;\r\n\r\n        // Outer glow ring\r\n        const glowGradient = this.ctx.createRadialGradient(\r\n            centerX, centerY, chipRadius * 0.7,\r\n            centerX, centerY, chipRadius * 1.4\r\n        );\r\n        const glowColor = isPlayer ? '#4CAF50' : '#F44336';\r\n        glowGradient.addColorStop(0, this.addAlpha(glowColor, 0.4 * glowIntensity));\r\n        glowGradient.addColorStop(1, 'transparent');\r\n\r\n        this.ctx.fillStyle = glowGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, chipRadius * 1.4, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Reset shadow for chip itself\r\n        this.ctx.shadowColor = 'transparent';\r\n        this.ctx.shadowBlur = 0;\r\n        this.ctx.shadowOffsetX = 0;\r\n        this.ctx.shadowOffsetY = 0;\r\n\r\n        // Main chip background with gradient\r\n        const chipGradient = this.ctx.createRadialGradient(\r\n            centerX - chipRadius * 0.3, centerY - chipRadius * 0.3, 0,\r\n            centerX, centerY, chipRadius\r\n        );\r\n\r\n        if (isPlayer) {\r\n            chipGradient.addColorStop(0, '#81C784');\r\n            chipGradient.addColorStop(0.7, '#4CAF50');\r\n            chipGradient.addColorStop(1, '#2E7D32');\r\n        } else {\r\n            chipGradient.addColorStop(0, '#EF5350');\r\n            chipGradient.addColorStop(0.7, '#F44336');\r\n            chipGradient.addColorStop(1, '#C62828');\r\n        }\r\n\r\n        this.ctx.fillStyle = chipGradient;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, chipRadius * pulseEffect, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n\r\n        // Inner ring detail\r\n        this.ctx.strokeStyle = isPlayer ? '#A5D6A7' : '#FFAB91';\r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, chipRadius * 0.8 * pulseEffect, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n\r\n        // Outer border with neon effect\r\n        this.ctx.strokeStyle = isPlayer ? '#66BB6A' : '#FF7043';\r\n        this.ctx.lineWidth = 3;\r\n        this.ctx.shadowColor = isPlayer ? '#4CAF50' : '#F44336';\r\n        this.ctx.shadowBlur = 6 * glowIntensity;\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(centerX, centerY, chipRadius * pulseEffect, 0, Math.PI * 2);\r\n        this.ctx.stroke();\r\n\r\n        // Reset shadow for text\r\n        this.ctx.shadowColor = 'transparent';\r\n        this.ctx.shadowBlur = 0;\r\n\r\n        // Enhanced text styling\r\n        const fontSize = Math.max(10, chipRadius * 0.6);\r\n        this.ctx.font = `bold ${fontSize}px 'Orbitron', monospace`;\r\n        this.ctx.textAlign = 'center';\r\n        this.ctx.textBaseline = 'middle';\r\n\r\n        // Text shadow for better readability\r\n        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n        this.ctx.fillText(text, centerX + 1, centerY + 1);\r\n\r\n        // Main text with glow\r\n        this.ctx.fillStyle = '#FFFFFF';\r\n        this.ctx.shadowColor = '#FFFFFF';\r\n        this.ctx.shadowBlur = 4;\r\n        this.ctx.fillText(text, centerX, centerY);\r\n\r\n        // Add small decorative elements (chip details)\r\n        this.ctx.shadowColor = 'transparent';\r\n        this.ctx.shadowBlur = 0;\r\n\r\n        // Small dots around the edge for authentic chip look\r\n        const dotCount = 8;\r\n        const dotRadius = chipRadius * 0.9;\r\n        const dotSize = 1.5;\r\n\r\n        this.ctx.fillStyle = isPlayer ? '#2E7D32' : '#C62828';\r\n        for (let i = 0; i < dotCount; i++) {\r\n            const angle = (i / dotCount) * Math.PI * 2;\r\n            const dotX = centerX + Math.cos(angle) * dotRadius;\r\n            const dotY = centerY + Math.sin(angle) * dotRadius;\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n\r\n        this.ctx.restore();\r\n    }\r\n\r\n    darkenColor(color, amount) {\r\n        // Simple color darkening function\r\n        if (color.startsWith('#')) {\r\n            const num = parseInt(color.slice(1), 16);\r\n            const r = Math.max(0, Math.floor((num >> 16) * (1 - amount)));\r\n            const g = Math.max(0, Math.floor(((num >> 8) & 0x00FF) * (1 - amount)));\r\n            const b = Math.max(0, Math.floor((num & 0x0000FF) * (1 - amount)));\r\n            return `rgb(${r}, ${g}, ${b})`;\r\n        }\r\n        return color; // Return original if not hex\r\n    }\r\n\r\n    addAlpha(color, alpha) {\r\n        // Add alpha to any color format\r\n        if (color.startsWith('hsl(')) {\r\n            return color.replace('hsl(', 'hsla(').replace(')', `, ${alpha})`);\r\n        } else if (color.startsWith('#')) {\r\n            const num = parseInt(color.slice(1), 16);\r\n            const r = (num >> 16) & 255;\r\n            const g = (num >> 8) & 255;\r\n            const b = num & 255;\r\n            return `rgba(${r}, ${g}, ${b}, ${alpha})`;\r\n        } else if (color.startsWith('rgb(')) {\r\n            return color.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);\r\n        }\r\n        return color;\r\n    }\r\n\r\n    drawDebugInfo() {\r\n        if (this.player) {\r\n            this.ctx.fillStyle = '#fff';\r\n            this.ctx.font = '16px Arial';\r\n            this.ctx.fillText(`Player: ${Math.round(this.player.x)}, ${Math.round(this.player.y)}`, 10, this.canvas.height - 60);\r\n            this.ctx.fillText(`Camera: ${Math.round(this.camera.x)}, ${Math.round(this.camera.y)}`, 10, this.canvas.height - 40);\r\n            this.ctx.fillText(`Food: ${this.food.length}, Orbs: ${this.glowOrbs.length}`, 10, this.canvas.height - 20);\r\n        }\r\n    }\r\n\r\n    drawMinimap() {\r\n        // Skip if minimap context is not available\r\n        if (!this.minimapCtx || !this.minimap) {\r\n            // Only log occasionally to avoid spam\r\n            if (Math.random() < 0.001) {\r\n                console.log('Minimap not available - ctx:', !!this.minimapCtx, 'canvas:', !!this.minimap);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Clear minimap with dark background\r\n        this.minimapCtx.fillStyle = '#0a0a0a';\r\n        this.minimapCtx.fillRect(0, 0, this.minimap.width, this.minimap.height);\r\n\r\n        const scaleX = this.minimap.width / this.worldWidth;\r\n        const scaleY = this.minimap.height / this.worldHeight;\r\n\r\n        // Draw world border\r\n        this.minimapCtx.strokeStyle = '#444';\r\n        this.minimapCtx.lineWidth = 2;\r\n        this.minimapCtx.strokeRect(0, 0, this.minimap.width, this.minimap.height);\r\n\r\n        // Draw food clusters (sample some food for performance)\r\n        const foodSample = this.food.filter((_, i) => i % 10 === 0); // Show every 10th food item\r\n        foodSample.forEach(food => {\r\n            const x = food.x * scaleX;\r\n            const y = food.y * scaleY;\r\n\r\n            this.minimapCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(x, y, 0.5, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n        });\r\n\r\n        // Draw glow orbs with pulsing effect\r\n        this.glowOrbs.forEach(orb => {\r\n            const x = orb.x * scaleX;\r\n            const y = orb.y * scaleY;\r\n            const pulse = Math.sin(Date.now() * 0.005) * 0.5 + 1;\r\n\r\n            // Glow effect\r\n            this.minimapCtx.shadowColor = '#FFD700';\r\n            this.minimapCtx.shadowBlur = 3 * pulse;\r\n            this.minimapCtx.fillStyle = '#FFD700';\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(x, y, 1.5 * pulse, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n            this.minimapCtx.shadowBlur = 0;\r\n        });\r\n\r\n        // Draw weapons (in warfare mode)\r\n        if (this.gameMode === 'warfare' && this.weapons) {\r\n            this.weapons.forEach(weapon => {\r\n                const x = weapon.x * scaleX;\r\n                const y = weapon.y * scaleY;\r\n\r\n                this.minimapCtx.fillStyle = '#FF6B35';\r\n                this.minimapCtx.beginPath();\r\n                this.minimapCtx.arc(x, y, 1, 0, Math.PI * 2);\r\n                this.minimapCtx.fill();\r\n            });\r\n        }\r\n\r\n        // Draw projectiles (in warfare mode)\r\n        if (this.gameMode === 'warfare' && this.projectiles) {\r\n            this.projectiles.forEach(projectile => {\r\n                const x = projectile.x * scaleX;\r\n                const y = projectile.y * scaleY;\r\n\r\n                this.minimapCtx.fillStyle = '#FF0000';\r\n                this.minimapCtx.beginPath();\r\n                this.minimapCtx.arc(x, y, 0.5, 0, Math.PI * 2);\r\n                this.minimapCtx.fill();\r\n            });\r\n        }\r\n\r\n        // Draw remote players with enhanced visibility\r\n        const aliveRemotePlayers = this.remotePlayers.filter(player => player.alive);\r\n        console.log(`Total remote players: ${this.remotePlayers.length}, Alive remote players: ${aliveRemotePlayers.length}`);\r\n\r\n        aliveRemotePlayers.forEach((player) => {\r\n            const x = player.x * scaleX;\r\n            const y = player.y * scaleY;\r\n            const size = Math.max(3, Math.min(7, player.segments.length * 0.2 + 3)); // Larger, more visible\r\n\r\n            // Enhanced remote player visibility with glow\r\n            this.minimapCtx.shadowColor = player.color;\r\n            this.minimapCtx.shadowBlur = 6;\r\n\r\n            // Draw player body with solid color (no transparency for better visibility)\r\n            this.minimapCtx.fillStyle = player.color;\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(x, y, size, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n\r\n            // Draw direction indicator with contrasting color\r\n            const headX = x + Math.cos(player.angle || 0) * (size + 3);\r\n            const headY = y + Math.sin(player.angle || 0) * (size + 3);\r\n            this.minimapCtx.fillStyle = '#FFFFFF'; // White direction indicator for contrast\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(headX, headY, size * 0.4, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n\r\n            // Add player name indicator (small text)\r\n            if (player.username) {\r\n                this.minimapCtx.fillStyle = '#FFFFFF';\r\n                this.minimapCtx.font = '8px Arial';\r\n                this.minimapCtx.textAlign = 'center';\r\n                this.minimapCtx.fillText(player.username.substring(0, 3), x, y - size - 5);\r\n            }\r\n\r\n            this.minimapCtx.shadowBlur = 0;\r\n        });\r\n\r\n        // Draw player snake with enhanced visibility\r\n        if (this.player && this.player.alive) {\r\n            const x = this.player.x * scaleX;\r\n            const y = this.player.y * scaleY;\r\n            const size = Math.max(2, Math.min(5, this.player.segments.length * 0.1 + 2));\r\n\r\n            // Player glow effect\r\n            this.minimapCtx.shadowColor = '#4CAF50';\r\n            this.minimapCtx.shadowBlur = 5;\r\n\r\n            // Draw player body\r\n            this.minimapCtx.fillStyle = '#4CAF50';\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(x, y, size, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n\r\n            // Draw direction indicator for player\r\n            const headX = x + Math.cos(this.player.angle) * (size + 2);\r\n            const headY = y + Math.sin(this.player.angle) * (size + 2);\r\n\r\n            this.minimapCtx.strokeStyle = '#81C784';\r\n            this.minimapCtx.lineWidth = 2;\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.moveTo(x, y);\r\n            this.minimapCtx.lineTo(headX, headY);\r\n            this.minimapCtx.stroke();\r\n\r\n            this.minimapCtx.shadowBlur = 0;\r\n        }\r\n\r\n        // Draw camera view rectangle\r\n        const camX = this.camera.x * scaleX;\r\n        const camY = this.camera.y * scaleY;\r\n        const camW = this.canvas.width * scaleX;\r\n        const camH = this.canvas.height * scaleY;\r\n\r\n        this.minimapCtx.strokeStyle = 'rgba(76, 175, 80, 0.8)';\r\n        this.minimapCtx.lineWidth = 1;\r\n        this.minimapCtx.setLineDash([2, 2]);\r\n        this.minimapCtx.strokeRect(camX, camY, camW, camH);\r\n        this.minimapCtx.setLineDash([]);\r\n\r\n        // Add minimap title\r\n        this.minimapCtx.fillStyle = '#fff';\r\n        this.minimapCtx.font = '10px monospace';\r\n        this.minimapCtx.textAlign = 'center';\r\n        this.minimapCtx.fillText('RADAR', this.minimap.width / 2, 12);\r\n\r\n        // Add legend\r\n        let legendY = this.minimap.height - 25;\r\n        this.minimapCtx.font = '8px monospace';\r\n        this.minimapCtx.textAlign = 'left';\r\n\r\n        // Player legend\r\n        this.minimapCtx.fillStyle = '#4CAF50';\r\n        this.minimapCtx.beginPath();\r\n        this.minimapCtx.arc(10, legendY, 2, 0, Math.PI * 2);\r\n        this.minimapCtx.fill();\r\n        this.minimapCtx.fillStyle = '#fff';\r\n        this.minimapCtx.fillText('YOU', 16, legendY + 3);\r\n\r\n        // Remote players legend\r\n        this.minimapCtx.fillStyle = '#f44336';\r\n        this.minimapCtx.beginPath();\r\n        this.minimapCtx.arc(50, legendY, 2, 0, Math.PI * 2);\r\n        this.minimapCtx.fill();\r\n        this.minimapCtx.fillStyle = '#fff';\r\n        this.minimapCtx.fillText('PLAYERS', 56, legendY + 3);\r\n\r\n        // Orbs legend\r\n        this.minimapCtx.fillStyle = '#FFD700';\r\n        this.minimapCtx.beginPath();\r\n        this.minimapCtx.arc(80, legendY, 2, 0, Math.PI * 2);\r\n        this.minimapCtx.fill();\r\n        this.minimapCtx.fillStyle = '#fff';\r\n        this.minimapCtx.fillText('ORBS', 86, legendY + 3);\r\n\r\n        // Weapons legend (warfare mode only)\r\n        if (this.gameMode === 'warfare') {\r\n            this.minimapCtx.fillStyle = '#FF6B35';\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(130, legendY, 2, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n            this.minimapCtx.fillStyle = '#fff';\r\n            this.minimapCtx.fillText('WEAPONS', 136, legendY + 3);\r\n\r\n            legendY += 12;\r\n            this.minimapCtx.fillStyle = '#44FF44';\r\n            this.minimapCtx.beginPath();\r\n            this.minimapCtx.arc(130, legendY, 2, 0, Math.PI * 2);\r\n            this.minimapCtx.fill();\r\n            this.minimapCtx.fillStyle = '#fff';\r\n            this.minimapCtx.fillText('AMMO', 136, legendY + 3);\r\n        }\r\n    }\r\n\r\n    gameLoop() {\r\n        if (this.gameRunning) {\r\n            this.update();\r\n            this.render();\r\n        }\r\n\r\n        requestAnimationFrame(() => this.gameLoop());\r\n    }\r\n\r\n    // React integration methods\r\n    async start() {\r\n        // FIXED: Use the same initialization as restart() to ensure identical behavior\r\n        this.setupEventListeners();\r\n\r\n        // Initialize multiplayer if enabled\r\n        if (this.isMultiplayer) {\r\n            await this.initializeMultiplayer();\r\n        }\r\n\r\n        this.restart(); // This will do the complete initialization just like subsequent games\r\n        this.gameLoop(); // Start the game loop ONCE\r\n    }\r\n\r\n    setMinimapCanvas(minimapCanvas) {\r\n        console.log('Setting minimap canvas:', minimapCanvas);\r\n        this.minimap = minimapCanvas;\r\n        this.minimapCtx = minimapCanvas.getContext('2d');\r\n        this.minimap.width = 250;\r\n        this.minimap.height = 200;\r\n        console.log('Minimap setup complete:', {\r\n            canvas: !!this.minimap,\r\n            ctx: !!this.minimapCtx,\r\n            width: this.minimap.width,\r\n            height: this.minimap.height\r\n        });\r\n    }\r\n\r\n    restart() {\r\n        console.log('🔄🔄🔄 RESTART METHOD CALLED 🔄🔄🔄');\r\n        // Reset game state\r\n        this.gameRunning = true;\r\n        this.score = 0;\r\n        this.cashBalance = 0; // Reset cash balance\r\n        this.camera = { x: 1500, y: 1500 };\r\n\r\n        // Reset weapon system completely\r\n        this.weaponInventory = {\r\n            primaryWeapon: null,\r\n            secondaryWeapon: null,\r\n            sidearm: new Weapon(0, 0, 'sidearm'), // Always available\r\n            currentSlot: 'sidearm'\r\n        };\r\n        this.currentWeapon = this.weaponInventory.sidearm;\r\n        this.lastWeaponSlot = 'sidearm'; // For quick switching\r\n        this.currentWeaponIndex = 0;\r\n        this.lastShotTime = 0;\r\n        this.projectiles = [];\r\n\r\n        // Reset ammo inventory\r\n        this.ammoInventory = {\r\n            light_energy: 0,\r\n            medium_energy: 0,\r\n            heavy_energy: 0,\r\n            light_plasma: 0,\r\n            medium_plasma: 0,\r\n            heavy_plasma: 0,\r\n            missiles: 0,\r\n            rail_slugs: 0\r\n        };\r\n\r\n        // Reset powerup system\r\n        this.powerups = [];\r\n        this.cashedOut = false;\r\n        this.spectating = false;\r\n\r\n        // Reset player completely\r\n        this.player = new Snake(2000, 2000, '#4CAF50', true);\r\n        this.player.gameInstance = this; // Set game reference\r\n\r\n        // Reset all player properties to default state\r\n        this.player.speedMultiplier = 1.0; // Reset speed multiplier\r\n        this.player.boostCapRemoved = false; // Reset boost cap\r\n        this.player.boost = 100; // Reset boost to 100%\r\n        this.player.alive = true; // Ensure player is alive\r\n        this.player.segments = [{ x: 2000, y: 2000, health: 100, maxHealth: 100 }]; // Reset to single head segment\r\n        this.player.growthQueue = 0; // Reset growth queue\r\n\r\n        // Activate spawn invincibility for reset player\r\n        this.player.activateSpawnInvincibility(this.playerWager);\r\n\r\n        // Set player wager and starting cash for both modes (gambling mechanics in both)\r\n        this.playerWager = 50; // Default $50 wager\r\n        this.player.wager = this.playerWager;\r\n        // Give player starting cash equal to their wager\r\n        this.cashBalance = this.playerWager;\r\n\r\n        // Log initial player state for debugging\r\n        console.log('Player initialized with', this.player.segments.length, 'segments and $' + this.cashBalance + ' cash balance');\r\n        if (this.gameMode === 'classic') {\r\n            // In classic mode, score is separate from cash\r\n            this.score = 0;\r\n        } else {\r\n            // In warfare mode, score equals cash\r\n            this.score = this.cashBalance;\r\n        }\r\n\r\n        // MULTIPLAYER MODE: No AI snakes on restart\r\n        this.aiSnakes = [];\r\n        console.log('🔄 Multiplayer restart - AI snakes remain disabled');\r\n\r\n        // Reset game objects\r\n        this.food = [];\r\n        this.glowOrbs = [];\r\n        this.weapons = [];\r\n        this.generateFood();\r\n        this.generateGlowOrbs();\r\n\r\n        // DON'T start a new game loop - one is already running from start()\r\n        // The existing game loop will resume when gameRunning becomes true\r\n    }\r\n\r\n    cashOut() {\r\n        if (this.cashedOut || !this.player.alive) return;\r\n\r\n        // Check if player has gained cash beyond their initial wager\r\n        const initialWager = this.playerWager || 50;\r\n        if (this.cashBalance <= initialWager) {\r\n            console.log(`Cannot cash out: Current balance $${this.cashBalance} is not greater than initial wager $${initialWager}`);\r\n            return; // Cannot cash out if no profit made\r\n        }\r\n\r\n        console.log(`Player cashing out with $${this.cashBalance} (profit: $${this.cashBalance - initialWager})`);\r\n\r\n        // Record the cashout\r\n        this.cashedOut = true;\r\n        this.cashoutBalance = this.cashBalance;\r\n        this.spectating = true;\r\n\r\n        // \"Kill\" the player but don't create coins\r\n        this.player.alive = false;\r\n\r\n        // Update game state to trigger the modal\r\n        if (this.onStateUpdate) {\r\n            this.onStateUpdate({\r\n                score: this.score,\r\n                cashBalance: this.cashBalance,\r\n                length: this.player.length,\r\n                boost: this.player.boost,\r\n                weapon: this.currentWeapon ? this.currentWeapon.name : 'None',\r\n                weaponAmmo: this.currentWeapon ?\r\n                    (this.currentWeapon.maxAmmo === Infinity ? '∞' : `${this.currentWeapon.currentAmmo}/${this.currentWeapon.maxAmmo}`) :\r\n                    '0/0',\r\n                cooldown: 'Ready',\r\n                isGameOver: true,\r\n                finalScore: this.score,\r\n                finalLength: this.player.length,\r\n                cashedOut: true,\r\n                cashoutAmount: this.cashoutBalance\r\n            });\r\n        }\r\n    }\r\n\r\n    cycleThroughSnakes() {\r\n        if (!this.spectating) return;\r\n\r\n        // In multiplayer, spectate remote players instead of AI\r\n        const aliveSnakes = this.remotePlayers.filter(player => player.alive);\r\n        if (aliveSnakes.length === 0) return;\r\n\r\n        this.spectateTarget = (this.spectateTarget + 1) % aliveSnakes.length;\r\n        const targetSnake = aliveSnakes[this.spectateTarget];\r\n\r\n        // Update camera to follow the spectated snake\r\n        this.camera.x = targetSnake.x - this.canvas.width / 2;\r\n        this.camera.y = targetSnake.y - this.canvas.height / 2;\r\n    }\r\n\r\n    // ===== MULTIPLAYER METHODS =====\r\n\r\n    async initializeMultiplayer() {\r\n        if (!this.isMultiplayer || !this.multiplayerService) {\r\n            console.log('🌐 Multiplayer service already connected or not needed');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            console.log('🌐 Multiplayer service connected to game instance');\r\n\r\n            // Set up player ID if available\r\n            if (this.multiplayerService.playerId) {\r\n                this.playerId = this.multiplayerService.playerId;\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('❌ Failed to initialize multiplayer service:', error);\r\n        }\r\n    }\r\n\r\n    updateRemotePlayers() {\r\n        // Update remote players based on received data\r\n        this.remotePlayers.forEach(player => {\r\n            if (player.alive) {\r\n                // Interpolate position for smooth movement\r\n                this.interpolatePlayerPosition(player);\r\n\r\n                // Update player segments\r\n                if (player.segments && player.segments.length > 0) {\r\n                    this.updateRemotePlayerSegments(player);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    interpolatePlayerPosition(player) {\r\n        // Simple linear interpolation for smooth movement\r\n        if (player.targetX !== undefined && player.targetY !== undefined) {\r\n            const lerpFactor = 0.1; // Adjust for smoothness vs responsiveness\r\n            player.x += (player.targetX - player.x) * lerpFactor;\r\n            player.y += (player.targetY - player.y) * lerpFactor;\r\n        }\r\n    }\r\n\r\n    updateRemotePlayerSegments(player) {\r\n        // Update segments to follow the head\r\n        if (player.segments.length > 1) {\r\n            for (let i = 1; i < player.segments.length; i++) {\r\n                const prevSegment = player.segments[i - 1];\r\n                const currentSegment = player.segments[i];\r\n\r\n                const dx = prevSegment.x - currentSegment.x;\r\n                const dy = prevSegment.y - currentSegment.y;\r\n                const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n                if (distance > player.segmentDistance) {\r\n                    const ratio = player.segmentDistance / distance;\r\n                    currentSegment.x = prevSegment.x - dx * ratio;\r\n                    currentSegment.y = prevSegment.y - dy * ratio;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Broadcast game events to other players\r\n    broadcastGameEvent(eventType, data) {\r\n        if (this.multiplayerService && this.isMultiplayer) {\r\n            this.multiplayerService.broadcastGameEvent({\r\n                type: eventType,\r\n                playerId: this.playerId,\r\n                data: data,\r\n                timestamp: Date.now()\r\n            });\r\n        }\r\n    }\r\n\r\n    initializeGamepadSupport() {\r\n        // Check if gamepad API is supported\r\n        if (!('getGamepads' in navigator)) {\r\n            console.log('Gamepad API not supported');\r\n            return;\r\n        }\r\n\r\n        console.log('Initializing gamepad support...');\r\n        this.gamepads = {};\r\n        this.deadzone = 0.15;\r\n        this.buttonStates = {};\r\n        this.previousButtonStates = {};\r\n\r\n        // Controller mappings\r\n        this.controllerMapping = {\r\n            buttons: {\r\n                A: 0,           // A/Cross button (boost)\r\n                B: 1,           // B/Circle button (cancel)\r\n                X: 2,           // X/Square button (cashout)\r\n                Y: 3,           // Y/Triangle button (spectate next)\r\n                LB: 4,          // Left bumper (primary weapon)\r\n                RB: 5,          // Right bumper (secondary weapon)\r\n                LT: 6,          // Left trigger (sidearm)\r\n                RT: 7,          // Right trigger (shoot)\r\n                Back: 8,        // Back/Share button\r\n                Start: 9,       // Start/Options button\r\n                LS: 10,         // Left stick click\r\n                RS: 11,         // Right stick click\r\n                DPadUp: 12,     // D-pad up\r\n                DPadDown: 13,   // D-pad down\r\n                DPadLeft: 14,   // D-pad left\r\n                DPadRight: 15   // D-pad right\r\n            },\r\n            axes: {\r\n                LeftStickX: 0,  // Left stick horizontal\r\n                LeftStickY: 1,  // Left stick vertical\r\n                RightStickX: 2, // Right stick horizontal\r\n                RightStickY: 3  // Right stick vertical\r\n            }\r\n        };\r\n\r\n        // Listen for gamepad events\r\n        window.addEventListener('gamepadconnected', (e) => {\r\n            console.log('🎮 Gamepad connected:', e.gamepad.id);\r\n            console.log('🎮 Gamepad details:', {\r\n                id: e.gamepad.id,\r\n                index: e.gamepad.index,\r\n                buttons: e.gamepad.buttons.length,\r\n                axes: e.gamepad.axes.length\r\n            });\r\n            this.addGamepad(e.gamepad);\r\n        });\r\n\r\n        window.addEventListener('gamepaddisconnected', (e) => {\r\n            console.log('🎮 Gamepad disconnected:', e.gamepad.id);\r\n            this.removeGamepad(e.gamepad);\r\n        });\r\n\r\n        // Start gamepad polling\r\n        this.startGamepadPolling();\r\n        console.log('Gamepad support initialized successfully');\r\n\r\n        // Check for already connected gamepads\r\n        this.checkExistingGamepads();\r\n    }\r\n\r\n    checkExistingGamepads() {\r\n        console.log('🎮 Checking for existing gamepads...');\r\n        const gamepads = navigator.getGamepads();\r\n        let foundGamepads = 0;\r\n\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            if (gamepads[i]) {\r\n                console.log('🎮 Found existing gamepad:', {\r\n                    index: i,\r\n                    id: gamepads[i].id,\r\n                    connected: gamepads[i].connected\r\n                });\r\n                this.addGamepad(gamepads[i]);\r\n                foundGamepads++;\r\n            }\r\n        }\r\n\r\n        if (foundGamepads === 0) {\r\n            console.log('🎮 No gamepads currently connected. Connect a gamepad and press any button to activate it.');\r\n        } else {\r\n            console.log(`🎮 Found ${foundGamepads} connected gamepad(s)`);\r\n        }\r\n    }\r\n\r\n    addGamepad(gamepad) {\r\n        console.log('🎮 Adding gamepad to tracking:', gamepad.index);\r\n        this.gamepads[gamepad.index] = gamepad;\r\n        this.buttonStates[gamepad.index] = {};\r\n        this.previousButtonStates[gamepad.index] = {};\r\n        console.log('🎮 Total gamepads tracked:', Object.keys(this.gamepads).length);\r\n    }\r\n\r\n    removeGamepad(gamepad) {\r\n        delete this.gamepads[gamepad.index];\r\n        delete this.buttonStates[gamepad.index];\r\n        delete this.previousButtonStates[gamepad.index];\r\n    }\r\n\r\n    startGamepadPolling() {\r\n        const pollGamepads = () => {\r\n            this.updateGamepads();\r\n            requestAnimationFrame(pollGamepads);\r\n        };\r\n        pollGamepads();\r\n    }\r\n\r\n    updateGamepads() {\r\n        const gamepads = navigator.getGamepads();\r\n\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad && this.gamepads[i]) {\r\n                this.handleGamepadInput(gamepad);\r\n            }\r\n        }\r\n    }\r\n\r\n    handleGamepadInput(gamepad) {\r\n        // Store previous button states\r\n        this.previousButtonStates[gamepad.index] = { ...this.buttonStates[gamepad.index] };\r\n\r\n        // Update current button states\r\n        for (let i = 0; i < gamepad.buttons.length; i++) {\r\n            this.buttonStates[gamepad.index][i] = gamepad.buttons[i].pressed;\r\n        }\r\n\r\n        // Handle movement (left stick)\r\n        const leftX = gamepad.axes[this.controllerMapping.axes.LeftStickX];\r\n        const leftY = gamepad.axes[this.controllerMapping.axes.LeftStickY];\r\n\r\n        if (Math.abs(leftX) > this.deadzone || Math.abs(leftY) > this.deadzone) {\r\n            // Debug movement input\r\n            if (Math.random() < 0.01) { // Log occasionally to avoid spam\r\n                console.log('🎮 Gamepad movement:', { leftX: leftX.toFixed(2), leftY: leftY.toFixed(2) });\r\n            }\r\n\r\n            // Convert stick input to world coordinates\r\n            const worldX = this.player.x + leftX * 200; // Scale factor for movement\r\n            const worldY = this.player.y + leftY * 200;\r\n\r\n            // Update mouse position for snake direction\r\n            this.mouse.x = worldX - this.camera.x;\r\n            this.mouse.y = worldY - this.camera.y;\r\n        }\r\n\r\n        // Handle boost (A/Cross button)\r\n        const boostButton = this.controllerMapping.buttons.A;\r\n        const wasBoosting = this.boosting;\r\n        this.boosting = this.isButtonPressed(gamepad.index, boostButton);\r\n\r\n        if (this.boosting && !wasBoosting) {\r\n            console.log('🎮 Boost button pressed');\r\n        }\r\n\r\n        // Handle shooting (right trigger) - only if not invincible\r\n        const shootButton = this.controllerMapping.buttons.RT;\r\n        if (this.isButtonJustPressed(gamepad.index, shootButton) && !this.player.isInvincible()) {\r\n            console.log('🎮 Shoot button pressed');\r\n            this.shoot();\r\n        }\r\n\r\n        // Handle weapon switching\r\n        if (this.isButtonJustPressed(gamepad.index, this.controllerMapping.buttons.LB)) {\r\n            this.switchToWeapon('primaryWeapon');\r\n        }\r\n        if (this.isButtonJustPressed(gamepad.index, this.controllerMapping.buttons.RB)) {\r\n            this.switchToWeapon('secondaryWeapon');\r\n        }\r\n        if (this.isButtonJustPressed(gamepad.index, this.controllerMapping.buttons.LT)) {\r\n            this.switchToWeapon('sidearm');\r\n        }\r\n\r\n        // Handle cashout (X/Square button)\r\n        const cashoutButton = this.controllerMapping.buttons.X;\r\n        if (this.isButtonJustPressed(gamepad.index, cashoutButton)) {\r\n            this.cashOut();\r\n        }\r\n\r\n        // Handle spectate cycling (Y/Triangle button)\r\n        const spectateButton = this.controllerMapping.buttons.Y;\r\n        if (this.isButtonJustPressed(gamepad.index, spectateButton)) {\r\n            this.cycleThroughSnakes();\r\n        }\r\n    }\r\n\r\n    isButtonPressed(gamepadIndex, buttonIndex) {\r\n        return this.buttonStates[gamepadIndex] && this.buttonStates[gamepadIndex][buttonIndex];\r\n    }\r\n\r\n    isButtonJustPressed(gamepadIndex, buttonIndex) {\r\n        const current = this.buttonStates[gamepadIndex] && this.buttonStates[gamepadIndex][buttonIndex];\r\n        const previous = this.previousButtonStates[gamepadIndex] && this.previousButtonStates[gamepadIndex][buttonIndex];\r\n        return current && !previous;\r\n    }\r\n\r\n    destroy() {\r\n        console.log('Destroying game...');\r\n        this.gameRunning = false;\r\n\r\n        // Clean up gamepad support\r\n        if (this.gamepads) {\r\n            this.gamepads = {};\r\n            this.buttonStates = {};\r\n            this.previousButtonStates = {};\r\n        }\r\n\r\n        // Note: Event listeners are added inline, so they'll be cleaned up when canvas is removed\r\n        // No need to manually remove them since we don't store references\r\n    }\r\n\r\n    canShoot() {\r\n        return Date.now() - this.lastShotTime > this.weaponCooldown;\r\n    }\r\n\r\n    updateGameState() {\r\n        // Don't update game state if game is over - let the gameOver() method handle it\r\n        if (!this.gameRunning) {\r\n            console.log('Skipping updateGameState - game is not running');\r\n            return;\r\n        }\r\n\r\n        if (this.onStateUpdate) {\r\n            const weaponCooldownRemaining = this.currentWeapon ?\r\n                Math.max(0, this.currentWeapon.fireRate - (Date.now() - this.currentWeapon.lastShotTime)) : 0;\r\n            const cooldownText = weaponCooldownRemaining > 0 ?\r\n                `Cooldown: ${(weaponCooldownRemaining / 1000).toFixed(1)}s` :\r\n                'Ready';\r\n\r\n            // Calculate cooldown progress (0-100%)\r\n            const cooldownProgress = this.currentWeapon && this.currentWeapon.fireRate > 0 ?\r\n                Math.max(0, 100 - (weaponCooldownRemaining / this.currentWeapon.fireRate) * 100) : 100;\r\n\r\n            // Get weapon slot information\r\n            const weaponSlots = {\r\n                primary: this.weaponInventory.primaryWeapon ?\r\n                    `${this.weaponInventory.primaryWeapon.name} (${this.weaponInventory.primaryWeapon.currentAmmo}/${this.weaponInventory.primaryWeapon.maxAmmo})` :\r\n                    'Empty',\r\n                secondary: this.weaponInventory.secondaryWeapon ?\r\n                    `${this.weaponInventory.secondaryWeapon.name} (${this.weaponInventory.secondaryWeapon.currentAmmo}/${this.weaponInventory.secondaryWeapon.maxAmmo})` :\r\n                    'Empty',\r\n                sidearm: `${this.weaponInventory.sidearm.name} (∞)`\r\n            };\r\n\r\n            // Get ammo inventory\r\n            const ammoInventory = this.getAmmoInventory();\r\n\r\n            this.onStateUpdate({\r\n                score: this.score, // Score for classic mode, cash for warfare mode\r\n                cashBalance: this.cashBalance, // Always show cash balance\r\n                length: this.player.length,\r\n                boost: this.player.boost,\r\n                weapon: this.currentWeapon ? this.currentWeapon.name : 'None',\r\n                weaponAmmo: this.currentWeapon ?\r\n                    (this.currentWeapon.maxAmmo === Infinity ? '∞' : `${this.currentWeapon.currentAmmo}/${this.currentWeapon.maxAmmo}`) :\r\n                    '0/0',\r\n                weaponTier: this.currentWeapon ? `Tier ${this.currentWeapon.tier}` : 'None',\r\n                weaponSlots: weaponSlots,\r\n                currentSlot: this.weaponInventory.currentSlot,\r\n                cooldown: this.currentWeapon && this.currentWeapon.canShoot() ? 'Ready' : cooldownText,\r\n                cooldownProgress: cooldownProgress,\r\n                ammoInventory: ammoInventory,\r\n                isGameOver: !this.gameRunning || this.cashedOut, // Include cashout state\r\n                finalScore: this.gameMode === 'warfare' ? this.cashBalance : this.score,\r\n                finalLength: this.player.length,\r\n                cashedOut: this.cashedOut, // Preserve cashout state\r\n                cashoutAmount: this.cashoutBalance // Preserve cashout amount\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nclass Snake {\r\n    constructor(x, y, color, isPlayer = false) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.color = color;\r\n        this.isPlayer = isPlayer;\r\n        this.baseSize = 8;\r\n        this.speed = 4; // Increased from 2 to 4 for faster base movement\r\n        this.baseSpeed = 4; // Store base speed for calculations\r\n        this.speedMultiplier = 1.0; // Speed multiplier from food (100% = 1.0)\r\n        this.angle = Math.random() * Math.PI * 2;\r\n        this.targetAngle = this.angle;\r\n        this.alive = true;\r\n        this.boost = 100;\r\n        this.maxBoost = 100;\r\n        this.boostCapRemoved = false; // Track if boost cap has been removed by food\r\n\r\n        // Snake segments - Start with just head, growth is cash-based\r\n        this.segments = [{ x: x, y: y, health: 100, maxHealth: 100 }];\r\n\r\n        // Path tracking for continuous movement in classic mode\r\n        this.pathHistory = [{ x: x, y: y }]; // Store head's movement path, start with initial position\r\n        this.maxPathLength = 1000; // Increased for larger snakes\r\n        this.pathRecordDistance = 2; // Only record path points when head moves this distance\r\n\r\n        // Growth system - cash-based growth\r\n        this.growthProgress = 0; // Progress toward next segment (0-1)\r\n        this.growthRate = 0.02; // How fast to grow each frame\r\n\r\n        // Invincibility system for new spawns\r\n        this.invincible = false;\r\n        this.invincibilityEndTime = 0;\r\n        this.blinkPhase = 0; // For blinking animation\r\n        this.shrinkProgress = 0; // Progress toward shrinking\r\n        this.growthQueue = 0; // Queue for growth from food consumption\r\n\r\n        // AI Weapon System (for non-player snakes)\r\n        if (!isPlayer) {\r\n            this.weaponInventory = {\r\n                primaryWeapon: null,\r\n                secondaryWeapon: null,\r\n                sidearm: new Weapon(0, 0, 'sidearm'),\r\n                currentSlot: 'sidearm'\r\n            };\r\n            this.currentWeapon = this.weaponInventory.sidearm;\r\n            this.lastWeaponSlot = 'sidearm';\r\n\r\n            // AI ammo inventory\r\n            this.ammoInventory = {\r\n                light_energy: 0,\r\n                heavy_energy: 0,\r\n                plasma_cells: 0,\r\n                heavy_plasma: 0,\r\n                rockets: 0,\r\n                rail_slugs: 0\r\n            };\r\n\r\n            // AI Combat Intelligence\r\n            this.aiPersonality = this.generateAIPersonality();\r\n            this.lastShotTime = 0;\r\n            this.targetEnemy = null;\r\n            this.combatState = 'hunting'; // hunting, engaging, retreating, collecting\r\n            this.lastStateChange = Date.now();\r\n            this.threatLevel = 0;\r\n            this.aggressionLevel = Math.random() * 0.5 + 0.3; // 0.3-0.8\r\n            this.accuracy = 0.6 + Math.random() * 0.3; // 0.6-0.9\r\n            this.reactionTime = 200 + Math.random() * 300; // 200-500ms\r\n            this.lastDecisionTime = 0;\r\n            this.patrolTarget = { x: x, y: y };\r\n            this.lastKnownEnemyPos = null;\r\n            this.weaponPreference = this.generateWeaponPreference();\r\n        }\r\n\r\n        // Powerup system for all snakes\r\n        this.activePowerups = []; // Array of active powerup effects\r\n        this.powerupInventory = []; // Collected powerups not yet activated\r\n\r\n        // Gambling system properties\r\n        this.wager = 0; // Snake's wager amount\r\n        this.cashValue = 0; // Total cash value of this snake\r\n    }\r\n\r\n    get size() {\r\n        // Size directly correlates to cash balance - no cap on growth\r\n        const cashBalance = this.isPlayer ?\r\n            (this.gameInstance ? this.gameInstance.cashBalance : 50) :\r\n            (this.collectedCash || 50);\r\n\r\n        // Base size + cash-based scaling (no cap)\r\n        const cashMultiplier = Math.sqrt(cashBalance / 10); // Smooth scaling\r\n        return this.baseSize + cashMultiplier * 2; // Direct cash-to-size correlation\r\n    }\r\n\r\n    getGame() {\r\n        // Helper method to get game instance (will be set by game)\r\n        return this.gameInstance;\r\n    }\r\n\r\n    get length() {\r\n        // Always return actual segment count for consistency\r\n        return this.segments.length;\r\n    }\r\n\r\n    // Get target length based on cash balance for growth system\r\n    getTargetLength() {\r\n        // Target length based on cash balance\r\n        const cashBalance = this.isPlayer ?\r\n            (this.gameInstance ? this.gameInstance.cashBalance : 50) :\r\n            (this.collectedCash || 50);\r\n\r\n        // $10 = 1 segment beyond base 1, minimum 1 segment (head only)\r\n        const baseSegments = 1;\r\n        const cashPerSegment = 10;\r\n        const bonusSegments = Math.floor(cashBalance / cashPerSegment);\r\n        const targetLength = baseSegments + bonusSegments;\r\n\r\n        // Removed spam logging\r\n        return Math.max(baseSegments, targetLength);\r\n    }\r\n\r\n    get segmentDistance() {\r\n        return this.size * 1.2;\r\n    }\r\n\r\n    update(boosting = false) {\r\n        if (!this.alive) return;\r\n\r\n        // Smooth angle transition\r\n        let angleDiff = this.targetAngle - this.angle;\r\n        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;\r\n        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;\r\n\r\n        this.angle += angleDiff * 0.1;\r\n\r\n        // Handle boosting\r\n        let currentSpeed = this.baseSpeed * this.speedMultiplier; // Apply food speed multiplier\r\n        if (boosting && this.boost > 0) {\r\n            currentSpeed *= 2.5; // Increased from 2 to 2.5 for faster boost speed\r\n            this.boost -= 0.4; // Reduced from 1 to 0.4 for longer boost duration\r\n\r\n            // If boost reaches 0 and cap was removed, restore the cap\r\n            if (this.boost <= 0 && this.boostCapRemoved) {\r\n                this.boostCapRemoved = false;\r\n            }\r\n        } else if (!boosting) {\r\n            // Natural regeneration only goes up to maxBoost (100%)\r\n            // Only food can push boost beyond 100%\r\n            if (this.boost < this.maxBoost) {\r\n                this.boost += 0.5;\r\n            }\r\n        }\r\n\r\n        // Apply powerup speed multipliers (like battering ram)\r\n        currentSpeed *= this.getSpeedMultiplier();\r\n\r\n        // Move head\r\n        this.x += Math.cos(this.angle) * currentSpeed;\r\n        this.y += Math.sin(this.angle) * currentSpeed;\r\n\r\n        // Keep in world bounds\r\n        this.x = Math.max(this.size, Math.min(4000 - this.size, this.x));\r\n        this.y = Math.max(this.size, Math.min(4000 - this.size, this.y));\r\n\r\n        // Update head position\r\n        this.segments[0].x = this.x;\r\n        this.segments[0].y = this.y;\r\n\r\n        // Track head's path for continuous movement (classic mode)\r\n        if (this.gameInstance && this.gameInstance.gameMode === 'classic') {\r\n            // Only record path points when head moves a significant distance\r\n            const lastPoint = this.pathHistory[this.pathHistory.length - 1];\r\n            const distance = Math.hypot(this.x - lastPoint.x, this.y - lastPoint.y);\r\n\r\n            if (distance >= this.pathRecordDistance) {\r\n                this.pathHistory.push({ x: this.x, y: this.y });\r\n\r\n                // Limit path history length\r\n                if (this.pathHistory.length > this.maxPathLength) {\r\n                    this.pathHistory.shift();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle natural growth\r\n        this.handleGrowth();\r\n\r\n        // Update powerups\r\n        this.updatePowerups();\r\n\r\n        // Update invincibility\r\n        this.updateInvincibility();\r\n\r\n        // Update body segments - different behavior for classic vs warfare mode\r\n        if (this.gameInstance && this.gameInstance.gameMode === 'classic') {\r\n            // Classic mode: Continuous path following\r\n            this.updateSegmentsClassicMode();\r\n        } else {\r\n            // Warfare mode: Fluid/jelly-like movement\r\n            this.updateSegmentsWarfareMode();\r\n        }\r\n    }\r\n\r\n    updateSegmentsClassicMode() {\r\n        // Classic mode: Body segments continuously follow the head's path\r\n        if (this.pathHistory.length < 2 || this.segments.length < 2) return;\r\n\r\n        // Calculate total path length for better distribution\r\n        let totalPathLength = 0;\r\n        for (let i = 1; i < this.pathHistory.length; i++) {\r\n            const current = this.pathHistory[i];\r\n            const previous = this.pathHistory[i - 1];\r\n            totalPathLength += Math.hypot(current.x - previous.x, current.y - previous.y);\r\n        }\r\n\r\n        // If path is too short, fall back to simple following\r\n        const requiredPathLength = (this.segments.length - 1) * this.segmentDistance;\r\n        if (totalPathLength < requiredPathLength) {\r\n            this.updateSegmentsWarfareMode(); // Use warfare mode as fallback\r\n            return;\r\n        }\r\n\r\n        for (let i = 1; i < this.segments.length; i++) {\r\n            // Calculate how far back in the path this segment should be\r\n            const segmentDelay = i * this.segmentDistance;\r\n\r\n            // Find the appropriate position in the path history\r\n            let accumulatedDistance = 0;\r\n            let targetPoint = null;\r\n\r\n            // Start from the most recent point and work backwards\r\n            for (let j = this.pathHistory.length - 1; j > 0; j--) {\r\n                const current = this.pathHistory[j];\r\n                const previous = this.pathHistory[j - 1];\r\n                const stepDistance = Math.hypot(current.x - previous.x, current.y - previous.y);\r\n\r\n                if (accumulatedDistance + stepDistance >= segmentDelay) {\r\n                    // Interpolate between these two points\r\n                    const remainingDistance = segmentDelay - accumulatedDistance;\r\n                    const ratio = stepDistance > 0 ? remainingDistance / stepDistance : 0;\r\n\r\n                    targetPoint = {\r\n                        x: current.x - (current.x - previous.x) * ratio,\r\n                        y: current.y - (current.y - previous.y) * ratio\r\n                    };\r\n                    break;\r\n                }\r\n\r\n                accumulatedDistance += stepDistance;\r\n            }\r\n\r\n            // If we found a target point, move the segment there smoothly\r\n            if (targetPoint) {\r\n                // Add some smoothing to prevent jittery movement\r\n                const smoothing = 0.8; // Higher value = more direct following\r\n                this.segments[i].x += (targetPoint.x - this.segments[i].x) * smoothing;\r\n                this.segments[i].y += (targetPoint.y - this.segments[i].y) * smoothing;\r\n            } else {\r\n                // Fallback: use the oldest point in the path\r\n                const oldestPoint = this.pathHistory[0];\r\n                if (oldestPoint) {\r\n                    const smoothing = 0.3;\r\n                    this.segments[i].x += (oldestPoint.x - this.segments[i].x) * smoothing;\r\n                    this.segments[i].y += (oldestPoint.y - this.segments[i].y) * smoothing;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    updateSegmentsWarfareMode() {\r\n        // Warfare mode: Fluid/jelly-like movement (original behavior)\r\n        for (let i = 1; i < this.segments.length; i++) {\r\n            const prev = this.segments[i - 1];\r\n            const current = this.segments[i];\r\n\r\n            const dx = prev.x - current.x;\r\n            const dy = prev.y - current.y;\r\n            const distance = Math.hypot(dx, dy);\r\n\r\n            if (distance > this.segmentDistance) {\r\n                // Fluid movement - segments follow with slight delay and smoothing\r\n                const angle = Math.atan2(dy, dx);\r\n                const targetX = prev.x - Math.cos(angle) * this.segmentDistance;\r\n                const targetY = prev.y - Math.sin(angle) * this.segmentDistance;\r\n\r\n                // Smooth interpolation for jelly-like effect\r\n                const smoothing = 0.3; // Adjust for more/less fluid movement\r\n                current.x += (targetX - current.x) * smoothing;\r\n                current.y += (targetY - current.y) * smoothing;\r\n            }\r\n        }\r\n    }\r\n\r\n    activateSpawnInvincibility(cashBalance) {\r\n        // Calculate invincibility duration based on cash balance\r\n        // Formula: 1 second base + 0.02 seconds per dollar (max 3 seconds)\r\n        const baseDuration = 1000; // 1 second base\r\n        const perDollarDuration = 20; // 0.02 seconds per dollar\r\n        const maxDuration = 3000; // 3 seconds maximum\r\n\r\n        const duration = Math.min(baseDuration + (cashBalance * perDollarDuration), maxDuration);\r\n\r\n        this.invincible = true;\r\n        this.invincibilityEndTime = Date.now() + duration;\r\n        this.blinkPhase = 0;\r\n\r\n        console.log(`Snake activated invincibility for ${duration/1000} seconds (cash: $${cashBalance})`);\r\n    }\r\n\r\n    updateInvincibility() {\r\n        if (this.invincible) {\r\n            const now = Date.now();\r\n            if (now >= this.invincibilityEndTime) {\r\n                this.invincible = false;\r\n                console.log('Snake invincibility expired');\r\n            } else {\r\n                // Update blinking animation\r\n                this.blinkPhase += 0.3; // Adjust speed of blinking\r\n            }\r\n        }\r\n    }\r\n\r\n    isInvincible() {\r\n        return this.invincible && Date.now() < this.invincibilityEndTime;\r\n    }\r\n\r\n    handleGrowth() {\r\n        // Cash-based growth system - snake size determined by cash balance\r\n        const targetLength = this.getTargetLength();\r\n        const currentLength = this.segments.length;\r\n\r\n        if (targetLength > currentLength) {\r\n            // Need to grow based on cash balance\r\n            this.growthProgress += this.growthRate * 2; // Smooth growth animation\r\n            if (this.growthProgress >= 1) {\r\n                this.addSegment();\r\n                this.growthProgress = 0;\r\n            }\r\n        } else if (targetLength < currentLength && currentLength > 3) {\r\n            // Need to shrink (but keep minimum 3 segments)\r\n            this.shrinkProgress = (this.shrinkProgress || 0) + this.growthRate;\r\n            if (this.shrinkProgress >= 1) {\r\n                this.removeSegment();\r\n                this.shrinkProgress = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    addSegment() {\r\n        // Add segment between head and body for more natural growth\r\n        // This makes the snake grow from the middle, keeping head moving and tail stationary\r\n        if (this.segments.length < 2) {\r\n            // If only head exists, add first body segment behind it\r\n            const head = this.segments[0];\r\n            this.segments.push({\r\n                x: head.x - Math.cos(this.angle) * this.segmentDistance,\r\n                y: head.y - Math.sin(this.angle) * this.segmentDistance,\r\n                health: 100,\r\n                maxHealth: 100\r\n            });\r\n        } else {\r\n            // Insert new segment between head and first body segment\r\n            const head = this.segments[0];\r\n            const firstBody = this.segments[1];\r\n\r\n            const newSegment = {\r\n                x: (head.x + firstBody.x) / 2,\r\n                y: (head.y + firstBody.y) / 2,\r\n                health: 100,\r\n                maxHealth: 100\r\n            };\r\n\r\n            // Insert at position 1 (between head and body)\r\n            this.segments.splice(1, 0, newSegment);\r\n        }\r\n    }\r\n\r\n    removeSegment() {\r\n        // Remove the tail segment (but keep minimum 3 segments)\r\n        if (this.segments.length > 3) {\r\n            this.segments.pop();\r\n        }\r\n    }\r\n\r\n    grow() {\r\n        // Instead of immediately adding segments, queue them for natural growth\r\n        this.growthQueue += 2; // Grow by 2 segments per food\r\n    }\r\n\r\n    // Add speed boost from food consumption (warfare mode)\r\n    addSpeedBoost(percentage) {\r\n        this.speedMultiplier += percentage / 100; // Convert percentage to decimal\r\n        // No cap on speed - can go beyond 100%\r\n    }\r\n\r\n    // AI Personality Generation\r\n    generateAIPersonality() {\r\n        const personalities = [\r\n            { name: 'Aggressive', aggression: 0.8, caution: 0.2, teamwork: 0.3 },\r\n            { name: 'Tactical', aggression: 0.5, caution: 0.7, teamwork: 0.6 },\r\n            { name: 'Sniper', aggression: 0.4, caution: 0.8, teamwork: 0.4 },\r\n            { name: 'Berserker', aggression: 0.9, caution: 0.1, teamwork: 0.2 },\r\n            { name: 'Support', aggression: 0.3, caution: 0.6, teamwork: 0.8 },\r\n            { name: 'Hunter', aggression: 0.6, caution: 0.5, teamwork: 0.5 }\r\n        ];\r\n        return personalities[Math.floor(Math.random() * personalities.length)];\r\n    }\r\n\r\n    generateWeaponPreference() {\r\n        const preferences = [\r\n            'laser', 'plasma', 'rocket', 'rail', 'balanced'\r\n        ];\r\n        return preferences[Math.floor(Math.random() * preferences.length)];\r\n    }\r\n\r\n    // AI Weapon Management\r\n    addWeaponToInventory(weapon) {\r\n        if (!this.weaponInventory) return;\r\n\r\n        // Try to add to primary slot first, then secondary\r\n        if (!this.weaponInventory.primaryWeapon) {\r\n            this.weaponInventory.primaryWeapon = weapon;\r\n            this.switchToWeapon('primaryWeapon');\r\n        } else if (!this.weaponInventory.secondaryWeapon) {\r\n            this.weaponInventory.secondaryWeapon = weapon;\r\n            this.switchToWeapon('secondaryWeapon');\r\n        } else {\r\n            // Replace current weapon based on preference\r\n            const currentSlot = this.weaponInventory.currentSlot;\r\n            if (currentSlot !== 'sidearm') {\r\n                this.weaponInventory[currentSlot] = weapon;\r\n                this.currentWeapon = weapon;\r\n            } else {\r\n                // If sidearm is active, replace primary\r\n                this.weaponInventory.primaryWeapon = weapon;\r\n                this.switchToWeapon('primaryWeapon');\r\n            }\r\n        }\r\n    }\r\n\r\n    switchToWeapon(slot) {\r\n        if (!this.weaponInventory) return;\r\n\r\n        const weapon = this.weaponInventory[slot];\r\n        if (weapon && (weapon.currentAmmo > 0 || weapon.maxAmmo === Infinity)) {\r\n            this.lastWeaponSlot = this.weaponInventory.currentSlot;\r\n            this.weaponInventory.currentSlot = slot;\r\n            this.currentWeapon = weapon;\r\n        }\r\n    }\r\n\r\n    // Powerup Management\r\n    addPowerup(powerup) {\r\n        // Add powerup to inventory for later activation\r\n        this.powerupInventory.push({\r\n            type: powerup.type,\r\n            config: powerup.config,\r\n            name: powerup.name,\r\n            duration: powerup.duration,\r\n            damageReduction: powerup.damageReduction,\r\n            headProtection: powerup.headProtection,\r\n            boostDamage: powerup.boostDamage,\r\n            speedBoost: powerup.speedBoost,\r\n            helmetHealth: powerup.helmetHealth,\r\n            description: powerup.description\r\n        });\r\n    }\r\n\r\n    activatePowerup(powerupType) {\r\n        // Find powerup in inventory\r\n        const powerupIndex = this.powerupInventory.findIndex(p => p.type === powerupType);\r\n        if (powerupIndex === -1) return false;\r\n\r\n        const powerup = this.powerupInventory[powerupIndex];\r\n\r\n        // Remove from inventory\r\n        this.powerupInventory.splice(powerupIndex, 1);\r\n\r\n        // Add to active powerups with expiration time\r\n        const activePowerup = {\r\n            ...powerup,\r\n            startTime: Date.now(),\r\n            expirationTime: Date.now() + powerup.duration,\r\n            currentHelmetHealth: powerup.helmetHealth || 0 // Track current helmet health\r\n        };\r\n\r\n        // Remove any existing powerup of the same type\r\n        this.activePowerups = this.activePowerups.filter(p => p.type !== powerupType);\r\n\r\n        // Add new powerup\r\n        this.activePowerups.push(activePowerup);\r\n\r\n        return true;\r\n    }\r\n\r\n    updatePowerups() {\r\n        const currentTime = Date.now();\r\n\r\n        // Remove expired powerups\r\n        this.activePowerups = this.activePowerups.filter(powerup => {\r\n            return currentTime < powerup.expirationTime;\r\n        });\r\n    }\r\n\r\n    getDamageReduction() {\r\n        let totalReduction = 0;\r\n        this.activePowerups.forEach(powerup => {\r\n            if (powerup.damageReduction) {\r\n                totalReduction = Math.max(totalReduction, powerup.damageReduction);\r\n            }\r\n        });\r\n        return Math.min(totalReduction, 0.95); // Cap at 95% reduction\r\n    }\r\n\r\n    getHeadProtection() {\r\n        let totalProtection = 0;\r\n        this.activePowerups.forEach(powerup => {\r\n            if (powerup.headProtection) {\r\n                totalProtection = Math.max(totalProtection, powerup.headProtection);\r\n            }\r\n        });\r\n        return Math.min(totalProtection, 0.99); // Cap at 99% protection\r\n    }\r\n\r\n    getBoostDamage() {\r\n        let totalDamage = 0;\r\n        this.activePowerups.forEach(powerup => {\r\n            if (powerup.boostDamage) {\r\n                totalDamage += powerup.boostDamage;\r\n            }\r\n        });\r\n        return totalDamage;\r\n    }\r\n\r\n    hasActivePowerup(type) {\r\n        return this.activePowerups.some(powerup => powerup.type === type);\r\n    }\r\n\r\n    getSpeedMultiplier() {\r\n        let speedMultiplier = 1.0;\r\n        this.activePowerups.forEach(powerup => {\r\n            if (powerup.speedBoost) {\r\n                speedMultiplier *= powerup.speedBoost;\r\n            }\r\n        });\r\n        return speedMultiplier;\r\n    }\r\n\r\n    damageHelmet(damage) {\r\n        const helmet = this.activePowerups.find(p => p.type === 'helmet');\r\n        if (helmet && helmet.currentHelmetHealth > 0) {\r\n            helmet.currentHelmetHealth -= damage;\r\n\r\n            if (helmet.currentHelmetHealth <= 0) {\r\n                // Helmet is destroyed, remove it\r\n                this.activePowerups = this.activePowerups.filter(p => p.type !== 'helmet');\r\n                return true; // Helmet was destroyed\r\n            }\r\n            return false; // Helmet absorbed damage but still intact\r\n        }\r\n        return null; // No helmet equipped\r\n    }\r\n\r\n    getHelmetHealth() {\r\n        const helmet = this.activePowerups.find(p => p.type === 'helmet');\r\n        return helmet ? helmet.currentHelmetHealth : 0;\r\n    }\r\n\r\n    // AI Shooting Logic\r\n    canShoot() {\r\n        return this.currentWeapon && this.currentWeapon.canShoot();\r\n    }\r\n\r\n    shoot(targetX, targetY) {\r\n        if (!this.canShoot()) return false;\r\n\r\n        const dx = targetX - this.x;\r\n        const dy = targetY - this.y;\r\n        const angle = Math.atan2(dy, dx);\r\n\r\n        // Add AI inaccuracy\r\n        const inaccuracy = (1 - this.accuracy) * 0.3;\r\n        const finalAngle = angle + (Math.random() - 0.5) * inaccuracy;\r\n\r\n        // Use ammo from weapon\r\n        if (!this.currentWeapon.shoot()) return false;\r\n\r\n        return {\r\n            x: this.x,\r\n            y: this.y,\r\n            vx: Math.cos(finalAngle) * this.currentWeapon.projectileSpeed,\r\n            vy: Math.sin(finalAngle) * this.currentWeapon.projectileSpeed,\r\n            angle: finalAngle,\r\n            speed: this.currentWeapon.projectileSpeed,\r\n            damage: this.currentWeapon.damage,\r\n            type: this.currentWeapon.type,\r\n            owner: this,\r\n            animationOffset: Math.random() * Math.PI * 2\r\n        };\r\n    }\r\n\r\n    // Helper functions for enhanced snake visuals\r\n    darkenColor(color, amount) {\r\n        // Convert hex color to RGB and darken it\r\n        const hex = color.replace('#', '');\r\n        const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - amount));\r\n        const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - amount));\r\n        const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - amount));\r\n\r\n        return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;\r\n    }\r\n\r\n    addAlpha(color, alpha) {\r\n        // Add alpha channel to color\r\n        const hex = color.replace('#', '');\r\n        const r = parseInt(hex.substr(0, 2), 16);\r\n        const g = parseInt(hex.substr(2, 2), 16);\r\n        const b = parseInt(hex.substr(4, 2), 16);\r\n\r\n        return `rgba(${r}, ${g}, ${b}, ${alpha})`;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Global gamepad testing function for debugging\r\nwindow.testGamepads = function() {\r\n    console.log('🎮 Testing gamepad connectivity...');\r\n\r\n    if (!('getGamepads' in navigator)) {\r\n        console.log('❌ Gamepad API not supported in this browser');\r\n        return;\r\n    }\r\n\r\n    const gamepads = navigator.getGamepads();\r\n    console.log('🎮 Raw gamepad array:', gamepads);\r\n\r\n    let connectedCount = 0;\r\n    for (let i = 0; i < gamepads.length; i++) {\r\n        if (gamepads[i]) {\r\n            connectedCount++;\r\n            console.log(`🎮 Gamepad ${i}:`, {\r\n                id: gamepads[i].id,\r\n                connected: gamepads[i].connected,\r\n                buttons: gamepads[i].buttons.length,\r\n                axes: gamepads[i].axes.length,\r\n                mapping: gamepads[i].mapping\r\n            });\r\n\r\n            // Test button states\r\n            const pressedButtons = [];\r\n            for (let j = 0; j < gamepads[i].buttons.length; j++) {\r\n                if (gamepads[i].buttons[j].pressed) {\r\n                    pressedButtons.push(j);\r\n                }\r\n            }\r\n            if (pressedButtons.length > 0) {\r\n                console.log(`🎮 Pressed buttons on gamepad ${i}:`, pressedButtons);\r\n            }\r\n\r\n            // Test axis values\r\n            const activeAxes = [];\r\n            for (let j = 0; j < gamepads[i].axes.length; j++) {\r\n                if (Math.abs(gamepads[i].axes[j]) > 0.1) {\r\n                    activeAxes.push({ axis: j, value: gamepads[i].axes[j].toFixed(2) });\r\n                }\r\n            }\r\n            if (activeAxes.length > 0) {\r\n                console.log(`🎮 Active axes on gamepad ${i}:`, activeAxes);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (connectedCount === 0) {\r\n        console.log('🎮 No gamepads detected. Make sure your controller is connected and press any button on it.');\r\n    } else {\r\n        console.log(`🎮 Found ${connectedCount} connected gamepad(s)`);\r\n    }\r\n};\r\n\r\n// Export for ES6 modules\r\nexport { Game, Snake, Weapon };"],"names":["WEAPON_CONFIGS","sidearm","name","tier","damage","maxAmmo","Infinity","fireRate","projectileSpeed","accuracy","rarity","color","secondaryColor","glowColor","accentColor","ammoTypes","description","laser_pistol","plasma_smg","firingMode","laser_rifle","burstCount","burstDelay","burstCooldown","plasma_cannon","spreadAngle","rocket_launcher","rail_gun","minigun","spinUp","spinUpTime","maxSpinLevel","tracerRounds","AMMO_CONFIGS","light_energy","minAmount","maxAmount","heavy_energy","plasma_cells","heavy_plasma","rockets","rail_slugs","POWERUP_CONFIGS","helmet","type","duration","damageReduction","headProtection","helmetHealth","forcefield","armor_plating","battering_ram","boostDamage","speedBoost","shield_generator","Weapon","constructor","x","y","arguments","length","undefined","this","size","collected","randomWeaponType","animationOffset","Math","random","PI","config","setWeaponProperties","currentAmmo","lastShotTime","burstState","inBurst","shotsInBurst","lastBurstShotTime","burstCooldownStart","pulsePhase","rotationSpeed","types","weights","totalWeight","reduce","sum","weight","i","canShoot","now","Date","shoot","reload","ammoAmount","ammoNeeded","ammoToAdd","min","getAmmoPercentage","draw","ctx","cameraX","cameraY","screenX","screenY","canvas","width","height","time","drawWeaponContainer","drawAmmoIndicator","drawWeaponDetails","drawWeaponEffects","containerSize","sin","outerGradient","createRadialGradient","addColorStop","fillStyle","beginPath","arc","fill","save","translate","rotate","hexRadius","angle","hx","cos","hy","moveTo","lineTo","closePath","containerGradient","strokeStyle","lineWidth","stroke","innerHexRadius","restore","ammoPercentage","indicatorRadius","ammoAngle","ammoColor","lineCap","font","textAlign","textBaseline","fillText","concat","iconSize","drawSidearmWeaponIcon","drawLaserWeaponIcon","drawPlasmaWeaponIcon","drawMissileWeaponIcon","drawRailGunWeaponIcon","drawMinigunWeaponIcon","distance","particleX","particleY","particleSize","alpha","particleGradient","floor","toString","padStart","pulseSize","pulseGradient","fillRect","strokeRect","corePulse","offset","plasmaPulse","plasmaGradient","energyPulse","barrelRadius","barrelX","barrelY","flashGradient","Ammo","amount","randomAmmoType","setAmmoProperties","bobPhase","sparklePhase","customAmount","lightenColor","hex","replace","r","parseInt","substr","g","b","finalY","drawAmmoContainer","drawAmmoIcon","drawAmmoEffects","pulse","glowGradient","diamondSize","sparkleX","sparkleY","sparkleSize","Powerup","randomPowerupType","setPowerupProperties","Object","keys","map","powerupType","update","bobOffset","drawWeaponBubble","drawPowerupIcon","drawPowerupLabel","pulseIntensity","glowSize","bubbleGradient","highlightGradient","particleAngle","particleDistance","drawHelmetIcon","drawForcefieldIcon","drawArmorIcon","drawBatteringRamIcon","drawShieldGeneratorIcon","ringSize","setLineDash","lineDashOffset","label","labelY","bgWidth","measureText","padding","bgHeight","shadowColor","shadowBlur","Game","gameMode","console","log","getContext","minimap","minimapCtx","resizeCanvas","rect","getBoundingClientRect","newWidth","window","innerWidth","newHeight","innerHeight","setTimeout","addEventListener","worldWidth","worldHeight","weapons","ammo","powerups","projectiles","coins","playerWager","availableWagers","weaponInventory","primaryWeapon","secondaryWeapon","currentSlot","currentWeapon","lastWeaponSlot","ammoInventory","gameRunning","score","cashBalance","camera","currentKing","player","Snake","gameInstance","wager","activateSpawnInvincibility","segments","remotePlayers","isMultiplayer","roomId","playerId","realtimeChannel","multiplayerService","aiSnakes","food","glowOrbs","mouse","boosting","mouseHeld","generateFood","generateGlowOrbs","onStateUpdate","onGameOver","cashedOut","spectating","spectateTarget","cashoutBalance","init","push","filter","weapon","initializeGamepadSupport","foodCount","hue","vx","vy","glow","value","setupEventListeners","e","clientX","left","clientY","top","button","isInvincible","preventDefault","document","code","cashOut","cycleThroughSnakes","switchToWeapon","quickSwitchWeapon","slot","temp","addWeaponToInventory","getAmmoInventory","nonZeroAmmo","entries","forEach","_ref","reloadWeaponsFromInventory","ammoType","ammoToUse","reloadAIWeaponsFromInventory","snake","worldMouseX","worldMouseY","playerHead","dx","dy","atan2","weaponUsed","handleSequentialBurst","handleSpreadBurst","createProjectile","shotAngle","projectile","owner","creationTime","trail","isTracer","handleFullAutoFiring","updatePlayer","updateRemotePlayers","updateGlowOrbs","checkCollisions","updateCamera","updateKing","updateCoins","updateGameState","powerup","allSnakes","s","alive","sqrt","isPlayer","ammoItem","powerupItem","addPowerup","activatePowerup","shift","headDx","headDy","helmetDamageResult","damageHelmet","getHeadProtection","reducedDamage","health","convertSnakeToCoins","gameOver","hitSegment","segment","getDamageReduction","finalDamage","breakOffSegments","targetAngle","updateAISnake","updateWarfareAI","updateClassicAI","targetX","targetY","minDist","targetType","coin","dist","hypot","orb","threat","shouldBoost","boost","lastDecisionTime","reactionTime","situation","assessSituation","updateAICombatState","action","executeAIBehavior","shootTarget","switchWeapon","handleAIWeaponSwitch","nearbyEnemies","nearbyWeapons","nearbyAmmo","nearbyFood","nearbyOrbs","nearbyCoins","incomingProjectiles","threatLevel","opportunityLevel","allEnemies","detectionRange","enemy","hasWeapon","threatScore","calculateThreatScore","priority","calculateWeaponPriority","needed","isAmmoNeeded","projectileAngle","toSnakeAngle","angleDiff","abs","timeToImpact","dangerLevel","max","convertSnakeToFood","index","totalCashValue","collectedCash","totalCoins","valuePerCoin","segmentIndex","attacker","brokenSegments","splice","segmentValue","calculateSegmentValue","totalValueLost","updateSnakeCashValue","baseValue","cashValue","weaponPreference","_snake$weaponInventor","_snake$weaponInventor2","some","includes","timeSinceStateChange","lastStateChange","combatState","executeHuntingBehavior","executeEngagingBehavior","executeRetreatingBehavior","executeCollectingBehavior","target","sort","a","ratioA","patrolTarget","scoreA","predictedX","speed","predictedY","strafeAngle","shouldSwitchWeapon","escapeX","escapeY","targetDistance","longRange","closeRange","currentIndex","indexOf","nextSlot","vacuumRadius","pullStrength","foodMassValue","growthQueue","addSpeedBoost","boostCapRemoved","j","grow","otherSnake","snakeInvincible","otherSnakeInvincible","batteringRamDamage","getBoostDamage","maxBoost","knockbackAngle","colors","newSnake","_newSnake$aiPersonali","aiPersonality","round","maxFood","spawnAmount","gameOverState","cooldown","isGameOver","finalScore","finalLength","aliveSnakes","spectatedSnake","newKing","highestBalance","balance","render","drawGrid","drawFood","drawGlowOrbs","drawSnakes","drawWeapons","drawAmmo","drawPowerups","drawProjectiles","drawCoins","drawKingIndicator","drawDebugInfo","drawMinimap","sparkleIntensity","coinGradient","sparkleAngle","sparkleDistance","isFinite","warn","age","drawDefaultProjectile","drawLaserProjectile","drawPlasmaProjectile","drawMissileProjectile","drawRailGunProjectile","beamLength","sparkAngle","sparkDistance","sparkX","sparkY","drawProjectileTrail","arcAngle","arcLength","startX","startY","endX","endY","midX","midY","missileGradient","createLinearGradient","exhaustPulse","flameGradient","ellipse","fieldGradient","innerRadius","outerRadius","fieldSize","coreGradient","drawTracerRound","velocity","trailLength","trailStartX","trailStartY","gradient","maxAlpha","current","next","currentScreen","nextScreen","gridSize","beingVacuumed","closestSnake","minDistance","drawVacuumTrail","pulseAlpha","addAlpha","foodSize","foodX","foodY","headX","headY","normalizedDx","normalizedDy","trailProgress","trailX","trailY","lineAlpha","baseColor","outerAura","middleGlow","innerGlow","coreGlow","ringRadius","dashOffset","shiftedHue","shiftedColor","shiftGlow","drawRealisticSnake","blinkPhase","drawWagerDisplay","invincibilityGlow","boostGlow","drawSmoothSnakeBody","drawSnakePattern","drawSnakeHead","lineJoin","head","neck","neckX","neckY","dotSize","segmentRatio","auraSize","auraGradient","scaleSize","hexPoints","scaleAngle","scaleGradient","darkenColor","shineOpacity","headSize","eyeSize","eyeOffset","hasActivePowerup","activePowerups","p","drawBatteringRamEffect","drawActivePowerupEffects","eyeAngle","eyeDistance","eyeX","eyeY","eyeGlow","pupilSize","pupilX","pupilY","pupilGlow","tongueLength","tongueWidth","tongueAngle","tongueStartX","tongueStartY","tongueEndX","tongueEndY","forkLength","forkAngle","drawVacuumIndicator","drawCrown","cometLength","trailPoints","progress","trailDistance","trailSize","trailGradient","cometWidth","perpAngle","sparkSize","energyGlow","drawHelmet","healthRatio","getHelmetHealth","helmetSize","helmetColor","helmetGradient","visorGradient","numCracks","crackAngle","crackLength","barWidth","barX","barY","healthColor","crownSize","crownY","crownGradient","spikeWidth","spikeX","spikeHeight","gemX","gemY","kingX","kingY","centerX","centerY","radius","indicatorX","indicatorY","arrowSize","scale","crownX","distanceText","drawForcefieldEffect","drawArmorPlatingEffect","drawShieldGeneratorEffect","drawPowerupStatusIndicators","shieldSize","layer","layerSize","layerAlpha","particleGlow","plateSize","plateDistance","plateX","plateY","plateGradient","shieldRadius","domeGradient","ring","ringTime","ringAlpha","timeRatio","expirationTime","iconColor","timeColor","vacuumGlow","roundedBalance","parseFloat","toFixed","displayY","drawBountyChip","text","chipRadius","log10","pulseEffect","glowIntensity","shadowOffsetX","shadowOffsetY","chipGradient","fontSize","dotRadius","dotX","dotY","startsWith","num","slice","scaleX","scaleY","_","aliveRemotePlayers","username","substring","camX","camY","camW","camH","legendY","gameLoop","requestAnimationFrame","start","initializeMultiplayer","restart","setMinimapCanvas","minimapCanvas","currentWeaponIndex","medium_energy","light_plasma","medium_plasma","missiles","speedMultiplier","maxHealth","initialWager","weaponAmmo","cashoutAmount","targetSnake","error","interpolatePlayerPosition","updateRemotePlayerSegments","lerpFactor","prevSegment","currentSegment","segmentDistance","ratio","broadcastGameEvent","eventType","data","timestamp","navigator","gamepads","deadzone","buttonStates","previousButtonStates","controllerMapping","buttons","A","B","X","Y","LB","RB","LT","RT","Back","Start","LS","RS","DPadUp","DPadDown","DPadLeft","DPadRight","axes","LeftStickX","LeftStickY","RightStickX","RightStickY","gamepad","id","addGamepad","removeGamepad","startGamepadPolling","checkExistingGamepads","getGamepads","foundGamepads","connected","pollGamepads","updateGamepads","handleGamepadInput","_objectSpread","pressed","leftX","leftY","worldX","worldY","boostButton","wasBoosting","isButtonPressed","shootButton","isButtonJustPressed","cashoutButton","spectateButton","gamepadIndex","buttonIndex","previous","destroy","weaponCooldown","weaponCooldownRemaining","cooldownText","cooldownProgress","weaponSlots","primary","secondary","weaponTier","baseSize","baseSpeed","pathHistory","maxPathLength","pathRecordDistance","growthProgress","growthRate","invincible","invincibilityEndTime","shrinkProgress","generateAIPersonality","targetEnemy","aggressionLevel","lastKnownEnemyPos","generateWeaponPreference","powerupInventory","cashMultiplier","getGame","getTargetLength","targetLength","currentSpeed","getSpeedMultiplier","lastPoint","handleGrowth","updatePowerups","updateInvincibility","updateSegmentsClassicMode","updateSegmentsWarfareMode","totalPathLength","segmentDelay","accumulatedDistance","targetPoint","stepDistance","smoothing","oldestPoint","prev","currentLength","addSegment","removeSegment","firstBody","newSegment","pop","percentage","personalities","aggression","caution","teamwork","preferences","powerupIndex","findIndex","activePowerup","startTime","currentHelmetHealth","currentTime","totalReduction","totalProtection","totalDamage","find","inaccuracy","finalAngle","testGamepads","connectedCount","mapping","pressedButtons","activeAxes","axis"],"sourceRoot":""}