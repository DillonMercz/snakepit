{"version":3,"file":"static/js/244.03449e78.chunk.js","mappings":"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","sources":["services/MultiplayerService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase'\nimport { RealtimeChannel } from '@supabase/supabase-js'\n\nexport interface PlayerState {\n  id: string\n  username: string\n  x: number\n  y: number\n  angle: number\n  segments: Array<{ x: number; y: number; health?: number; maxHealth?: number }>\n  color: string\n  alive: boolean\n  cashBalance: number\n  boost: number\n  size: number\n  wager: number\n  isInvincible?: boolean\n  lastUpdate: number\n}\n\nexport interface GameRoom {\n  id: string\n  name: string\n  gameMode: 'classic' | 'warfare'\n  maxPlayers: number\n  currentPlayers: number\n  wagerAmount: number\n  status: 'waiting' | 'playing' | 'finished'\n  createdAt: string\n  hostId: string\n}\n\nexport interface GameEvent {\n  type: 'player_move' | 'player_death' | 'food_collected' | 'coin_collected' | 'weapon_fired' | 'player_joined' | 'player_left'\n  playerId: string\n  data: any\n  timestamp: number\n}\n\nexport class MultiplayerService {\n  private static instance: MultiplayerService\n  private channel: RealtimeChannel | null = null\n  private currentRoom: GameRoom | null = null\n  private playerId: string | null = null\n  private gameInstance: any = null\n  private updateInterval: NodeJS.Timeout | null = null\n\n  private constructor() {}\n\n  static getInstance(): MultiplayerService {\n    if (!MultiplayerService.instance) {\n      MultiplayerService.instance = new MultiplayerService()\n    }\n    return MultiplayerService.instance\n  }\n\n  // Initialize multiplayer for a game instance\n  async initializeMultiplayer(gameInstance: any, userId: string, username: string) {\n    console.log('üåê Initializing multiplayer service...')\n    this.gameInstance = gameInstance\n    this.playerId = userId\n\n    // Set up the game instance for multiplayer (only if gameInstance is provided)\n    if (gameInstance) {\n      gameInstance.playerId = userId\n      gameInstance.isMultiplayer = true\n    }\n\n    console.log('‚úÖ Multiplayer service initialized')\n    return true\n  }\n\n  // Set the game instance (public method)\n  setGameInstance(gameInstance: any) {\n    this.gameInstance = gameInstance\n    if (gameInstance && this.playerId) {\n      gameInstance.playerId = this.playerId\n      gameInstance.isMultiplayer = true\n    }\n  }\n\n  // Create a new game room\n  async createRoom(gameMode: 'classic' | 'warfare', wagerAmount: number, maxPlayers: number = 8): Promise<GameRoom | null> {\n    try {\n      console.log('üè† Creating new game room...', { gameMode, wagerAmount, maxPlayers })\n\n      const roomData = {\n        name: `${gameMode.toUpperCase()} Room`,\n        game_mode: gameMode,\n        max_players: maxPlayers,\n        current_players: 1,\n        wager_amount: wagerAmount,\n        status: 'waiting',\n        host_id: this.playerId,\n        created_at: new Date().toISOString()\n      }\n\n      const { data, error } = await supabase\n        .from('game_rooms')\n        .insert(roomData)\n        .select()\n        .single()\n\n      if (error) {\n        console.error('‚ùå Error creating room:', error)\n        return null\n      }\n\n      this.currentRoom = {\n        id: data.id,\n        name: data.name,\n        gameMode: data.game_mode,\n        maxPlayers: data.max_players,\n        currentPlayers: data.current_players,\n        wagerAmount: data.wager_amount,\n        status: data.status,\n        createdAt: data.created_at,\n        hostId: data.host_id\n      }\n\n      console.log('‚úÖ Room created:', this.currentRoom)\n      return this.currentRoom\n    } catch (error) {\n      console.error('‚ùå Error creating room:', error)\n      return null\n    }\n  }\n\n  // Join an existing room\n  async joinRoom(roomId: string): Promise<boolean> {\n    try {\n      console.log('üö™ Joining room:', roomId)\n\n      // Get room info\n      const { data: roomData, error: roomError } = await supabase\n        .from('game_rooms')\n        .select('*')\n        .eq('id', roomId)\n        .single()\n\n      if (roomError || !roomData) {\n        console.error('‚ùå Room not found:', roomError)\n        return false\n      }\n\n      // Check if room is full\n      if (roomData.current_players >= roomData.max_players) {\n        console.error('‚ùå Room is full')\n        return false\n      }\n\n      // Update room player count\n      const { error: updateError } = await supabase\n        .from('game_rooms')\n        .update({ current_players: roomData.current_players + 1 })\n        .eq('id', roomId)\n\n      if (updateError) {\n        console.error('‚ùå Error updating room:', updateError)\n        return false\n      }\n\n      this.currentRoom = {\n        id: roomData.id,\n        name: roomData.name,\n        gameMode: roomData.game_mode,\n        maxPlayers: roomData.max_players,\n        currentPlayers: roomData.current_players + 1,\n        wagerAmount: roomData.wager_amount,\n        status: roomData.status,\n        createdAt: roomData.created_at,\n        hostId: roomData.host_id\n      }\n\n      console.log('‚úÖ Joined room:', this.currentRoom)\n      return true\n    } catch (error) {\n      console.error('‚ùå Error joining room:', error)\n      return false\n    }\n  }\n\n  // Connect to real-time channel for the current room\n  async connectToRoom(): Promise<boolean> {\n    if (!this.currentRoom) {\n      console.error('‚ùå No current room to connect to')\n      return false\n    }\n\n    try {\n      console.log('üîó Connecting to real-time channel for room:', this.currentRoom.id)\n\n      // Create channel for this room\n      this.channel = supabase.channel(`game_room_${this.currentRoom.id}`)\n\n      // Listen for player state updates\n      this.channel.on('broadcast', { event: 'player_state' }, (payload) => {\n        this.handlePlayerStateUpdate(payload)\n      })\n\n      // Listen for game events\n      this.channel.on('broadcast', { event: 'game_event' }, (payload) => {\n        this.handleGameEvent(payload)\n      })\n\n      // Subscribe to the channel\n      this.channel.subscribe((status) => {\n        if (status === 'SUBSCRIBED') {\n          console.log('‚úÖ Connected to real-time channel')\n\n          // Start sending player updates\n          this.startPlayerUpdates()\n\n          // Announce player joined\n          this.broadcastGameEvent({\n            type: 'player_joined',\n            playerId: this.playerId!,\n            data: { username: this.gameInstance?.player?.username || 'Unknown' },\n            timestamp: Date.now()\n          })\n        } else {\n          console.error('‚ùå Failed to subscribe to channel:', status)\n        }\n      })\n\n      // Return true immediately as subscription is async\n      return true\n    } catch (error) {\n      console.error('‚ùå Error connecting to room:', error)\n      return false\n    }\n  }\n\n  // Start sending player position updates\n  private startPlayerUpdates() {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval)\n    }\n\n    this.updateInterval = setInterval(() => {\n      if (this.gameInstance?.player && this.channel) {\n        const playerState: PlayerState = {\n          id: this.playerId!,\n          username: this.gameInstance.player.username || 'Unknown',\n          x: this.gameInstance.player.x,\n          y: this.gameInstance.player.y,\n          angle: this.gameInstance.player.angle,\n          segments: this.gameInstance.player.segments,\n          color: this.gameInstance.player.color,\n          alive: this.gameInstance.player.alive,\n          cashBalance: this.gameInstance.cashBalance || 0,\n          boost: this.gameInstance.player.boost,\n          size: this.gameInstance.player.size,\n          wager: this.gameInstance.player.wager || 50,\n          isInvincible: this.gameInstance.player.isInvincible?.() || false,\n          lastUpdate: Date.now()\n        }\n\n        this.channel.send({\n          type: 'broadcast',\n          event: 'player_state',\n          payload: playerState\n        })\n      }\n    }, 50) // Send updates 20 times per second\n  }\n\n  // Handle incoming player state updates\n  private handlePlayerStateUpdate(payload: any) {\n    if (!this.gameInstance || payload.payload.id === this.playerId) {\n      return // Don't process our own updates\n    }\n\n    const playerState: PlayerState = payload.payload\n\n    // Find existing remote player or create new one\n    let remotePlayer = this.gameInstance.remotePlayers.find((p: any) => p.id === playerState.id)\n\n    if (!remotePlayer) {\n      // Create new remote player\n      remotePlayer = {\n        id: playerState.id,\n        username: playerState.username,\n        x: playerState.x,\n        y: playerState.y,\n        angle: playerState.angle,\n        segments: playerState.segments,\n        color: playerState.color,\n        alive: playerState.alive,\n        cashBalance: playerState.cashBalance,\n        boost: playerState.boost,\n        size: playerState.size,\n        wager: playerState.wager,\n        isInvincible: playerState.isInvincible,\n        segmentDistance: 15, // Default segment distance\n        isPlayer: false\n      }\n\n      this.gameInstance.remotePlayers.push(remotePlayer)\n      console.log('üë§ New player joined:', playerState.username)\n    } else {\n      // Update existing player\n      remotePlayer.targetX = playerState.x\n      remotePlayer.targetY = playerState.y\n      remotePlayer.angle = playerState.angle\n      remotePlayer.segments = playerState.segments\n      remotePlayer.alive = playerState.alive\n      remotePlayer.cashBalance = playerState.cashBalance\n      remotePlayer.boost = playerState.boost\n      remotePlayer.isInvincible = playerState.isInvincible\n    }\n  }\n\n  // Handle game events\n  private handleGameEvent(payload: any) {\n    const event: GameEvent = payload.payload\n    console.log('üéÆ Game event received:', event)\n\n    switch (event.type) {\n      case 'player_joined':\n        console.log(`üëã ${event.data.username} joined the game`)\n        break\n      case 'player_left':\n        console.log(`üëã Player left the game`)\n        // Remove player from remote players\n        if (this.gameInstance) {\n          this.gameInstance.remotePlayers = this.gameInstance.remotePlayers.filter(\n            (p: any) => p.id !== event.playerId\n          )\n        }\n        break\n      case 'player_death':\n        console.log(`üíÄ Player died:`, event.data)\n        break\n      // Add more event handlers as needed\n    }\n  }\n\n  // Broadcast a game event\n  broadcastGameEvent(event: GameEvent) {\n    if (this.channel) {\n      this.channel.send({\n        type: 'broadcast',\n        event: 'game_event',\n        payload: event\n      })\n    }\n  }\n\n  // Leave the current room\n  async leaveRoom() {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval)\n      this.updateInterval = null\n    }\n\n    if (this.channel) {\n      // Announce player leaving\n      this.broadcastGameEvent({\n        type: 'player_left',\n        playerId: this.playerId!,\n        data: {},\n        timestamp: Date.now()\n      })\n\n      await this.channel.unsubscribe()\n      this.channel = null\n    }\n\n    if (this.currentRoom) {\n      // Update room player count\n      try {\n        await supabase\n          .from('game_rooms')\n          .update({ current_players: Math.max(0, this.currentRoom.currentPlayers - 1) })\n          .eq('id', this.currentRoom.id)\n      } catch (error) {\n        console.error('‚ùå Error updating room on leave:', error)\n      }\n    }\n\n    this.currentRoom = null\n    console.log('üëã Left room')\n  }\n\n  // Get current room info\n  getCurrentRoom(): GameRoom | null {\n    return this.currentRoom\n  }\n\n  // Get available rooms\n  async getAvailableRooms(): Promise<GameRoom[]> {\n    try {\n      // Use the database function for better performance and accuracy\n      const { data, error } = await supabase\n        .rpc('get_available_rooms')\n\n      if (error) {\n        console.error('‚ùå Error fetching rooms:', error)\n        return []\n      }\n\n      return data.map((room: any) => ({\n        id: room.room_id,\n        name: room.room_name,\n        gameMode: room.game_mode,\n        maxPlayers: room.max_players,\n        currentPlayers: room.current_players,\n        wagerAmount: room.wager_amount,\n        status: 'waiting',\n        createdAt: room.created_at,\n        hostId: room.host_username // Note: this is username, not ID\n      }))\n    } catch (error) {\n      console.error('‚ùå Error fetching rooms:', error)\n      return []\n    }\n  }\n\n  // Cleanup\n  cleanup() {\n    this.leaveRoom()\n    this.gameInstance = null\n    this.playerId = null\n  }\n}\n\nexport default MultiplayerService\n"],"names":["MultiplayerService","constructor","channel","currentRoom","playerId","gameInstance","updateInterval","getInstance","instance","initializeMultiplayer","userId","username","console","log","this","isMultiplayer","setGameInstance","createRoom","gameMode","wagerAmount","maxPlayers","arguments","length","undefined","roomData","name","concat","toUpperCase","game_mode","max_players","current_players","wager_amount","status","host_id","created_at","Date","toISOString","data","error","supabase","from","insert","select","single","id","currentPlayers","createdAt","hostId","joinRoom","roomId","roomError","eq","updateError","update","connectToRoom","on","event","payload","handlePlayerStateUpdate","handleGameEvent","subscribe","_this$gameInstance","_this$gameInstance$pl","startPlayerUpdates","broadcastGameEvent","type","player","timestamp","now","clearInterval","setInterval","_this$gameInstance2","_this$gameInstance$pl2","_this$gameInstance$pl3","playerState","x","y","angle","segments","color","alive","cashBalance","boost","size","wager","isInvincible","call","lastUpdate","send","remotePlayer","remotePlayers","find","p","targetX","targetY","segmentDistance","isPlayer","push","filter","leaveRoom","unsubscribe","Math","max","getCurrentRoom","getAvailableRooms","rpc","map","room","room_id","room_name","host_username","cleanup"],"sourceRoot":""}